[{"title":"CTF--python hashlib库中MD5用法","date":"2017-01-17T08:21:33.455Z","path":"2017/01/17/CTF_Python_MD5/","text":"一、前言：这篇博客介绍python hashlib库的MD5用法，通过一道具体的ctf题目来引入 原题目链接 二、原题：question 破解下面的密文： 83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 13823 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 11264 68 62 70 61 112 111 112 flag格式flag{}[这里注意，如果题目显示一些乱码，需要更改浏览器编码为GBK，不同浏览器修改方式不同] 三、代码及注释# -*- coding: utf-8 -*- import hashlib s=&#39;83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110 127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 138 23 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 112 64 68 62 70 61 112 111 112&#39; l=s.split(&#39; &#39;) t=&#39;&#39; for i in l: t+=chr(int(i)-13) #得到部分flag及其md5 print t m=t[-32:] dic=&#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~ &#39; #可打印字符 for i1 in dic: #枚举所有情况，进行md5后与给定md5比较，相等，即为flag for i2 in dic: for i3 in dic: for i4 in dic: md5 = hashlib.md5() b = &#39;flag{www_shiyanbar_com_is_very_good_&#39; +i1+i2+i3+i4+&#39;}&#39; md5.update(b) if md5.hexdigest() == m: print &#39;%s&#39; % b python库中的md5函数使用简便，而且运行速度很快","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"},{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"},{"name":"md5","slug":"md5","permalink":"http://www.lovebear.top/tags/md5/"}]},{"title":"CTF--欧几里得求逆","date":"2017-01-17T07:20:37.210Z","path":"2017/01/17/CTF_EuclidInversion/","text":"一、前言：最近做了一道ctf的题目，是关于仿射函数的，本身题目比较简单，这里不过多介绍，其中有一个环节需要进行乘法逆元的求解，这里需要用到欧几里得求逆的方法，是一种很好的求乘法逆元的思想，这里简单介绍，也相当于做一下笔记。 二、算法介绍：44 5 0 1|8 4 1 -8|1 1 -8 9 如上述，假设我们要求5对44的模逆 第一行为模 第二行第一个数为元，0，1固定，8是44/5的值 第三行4为(44 mod 5)，1为右上角的值，-8是(0-1*8)[0，1，8为上一行的后三个数]，1为5/4 第四行的1为(5 mod 4)， -8为右上角的值， 9为(1-(-8)*1) 当最左边出现1的时候，9就是我们需要的值，即5对44模逆的结果为9 三、代码：def Moni(a,n): p = a q = n x = 0 y = 1 z = int(q)/p while(1 != p): t = p p = q % p q = t t = y y = x - y*z x = t z = int(q)/p y=y%n if(y &lt; 0): y += n return y &#39;&#39;&#39; p x y(q=last p)|z 26 5 0 1|5 1 5 -5(21) &#39;&#39;&#39; y=Moni(5,26)","tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"CTF--快速提交2--基于学习的快速提交","date":"2017-01-12T01:29:01.340Z","path":"2017/01/12/CTF_Fastpost2/","text":"一、前言：上次介绍了简单的fastpost方法，这次我们来看一个稍微复杂的，基于学习的快速提交 原题目链接 二、原题：question 红色的数字会在短时间内变化，所以通过脚本解决这个问题。 三、代码及注释# -*- coding: utf-8 -*- import requests import re url = &#39;http://ctf5.shiyanbar.com/ppc/acsii.php&#39; #post的地址 session = requests.Session() f = session.get(url) #获取界面html zz = r&#39;red&quot;&gt;(.*)&lt;/div&gt;&#39; #匹配红色字段 a = re.findall(zz,f.content)[0] a=a.replace(&#39;&lt;br/&gt;&#39;,&#39;&lt;br /&gt;&#39;) a=a.replace(&#39;&lt;br&gt;&#39;,&#39;&lt;br /&gt;&#39;) #图形替换为对应的数字 a=a.replace(&#39;xxxxx&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;&amp;nbsp;xxxx&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;xxxxx&lt;br /&gt;&#39;,&#39;5&#39;) a=a.replace(&#39;&amp;nbsp;xx&lt;br /&gt;&amp;nbsp;&amp;nbsp;x&amp;nbsp;x&amp;nbsp;&amp;nbsp;&lt;br /&gt;&amp;nbsp;&amp;nbsp;x&amp;nbsp;&amp;nbsp;&lt;br /&gt;&amp;nbsp;&amp;nbsp;x&amp;nbsp;&amp;nbsp;&lt;br /&gt;xxxxx&lt;br /&gt;&#39;,&#39;1&#39;) a=a.replace(&#39;&amp;nbsp;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;xxxxx&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&#39;,&#39;4&#39;) a=a.replace(&#39;&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;&#39;,&#39;0&#39;) a=a.replace(&#39;&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;&amp;nbsp;xx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;&#39;,&#39;8&#39;) a=a.replace(&#39;&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&amp;nbsp;&lt;br /&gt;&amp;nbsp;&amp;nbsp;xx&amp;nbsp;&lt;br /&gt;&amp;nbsp;x&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;xxxxx&lt;br /&gt;&#39;,&#39;2&#39;) a=a.replace(&#39;&lt;br /&gt;&lt;br /&gt;&#39;,&#39;&#39;) a=a.replace(&#39;&lt;br /&gt;&#39;,&#39;&#39;) post = session.post(url,{&#39;inputNumber&#39;:a}) #获得html print post.content 得到了flag，可以提交啦，以后的fastpost都可以套用这个。","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"},{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"CTF--快速提交（fastpost）","date":"2017-01-08T13:07:08.628Z","path":"2017/01/08/CTF_Fastpost/","text":"一、前言：CTF比赛中，fastpost问题应该是非常常见的题型，这种类型题的代码基本类似，采用脚本自动提交即可，这里给出python2版本的代码，采用的是request库 原题目链接 二、原题： 红色的数字会在短时间内变化，所以通过脚本解决这个问题。 三、代码及注释# -*- coding: utf-8 -*- import hashlib import requests import re url = &#39;http://ctf5.shiyanbar.com/ppc/sd.php&#39; #post的地址 session = requests.Session() f = session.get(url) #获取界面html zz = r&#39;red&quot;&gt;(.*)&lt;/div&gt;&#39; #匹配红色字段 a = re.findall(zz,f.content)[0]#获取题目中的sha1值 for x in range (0,100001): sx = str(x) xmd5 = hashlib.md5(sx).hexdigest()#md5加密 xsha1 = hashlib.sha1(xmd5).hexdigest()#sha1加密 if xsha1 == a:#比较是否与题目的sha1值相同 post = session.post(url,{&#39;inputNumber&#39;:x}) #获得html print post.content 得到了flag，可以提交啦，以后的fastpost都可以套用这个。","tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"Linux开机自动运行普通用户python脚本","date":"2017-01-02T03:37:40.926Z","path":"2017/01/02/AutoRunPython_Linux/","text":"一、前言：最近无聊写了一个监控键盘按键的简单恶意软件，因为我的电脑不可能24小时开机监控，费时费力，于是想到我还有个云服务器，可以在云服务器上持续运行我的服务接收端来进行24小时监控。由于我的恶意软件用python编写的（开发挺快的），所以需要在服务器中设置开机自动运行我的python服务器脚本，服务器环境为linux。windows服务器比较简单，把要启动的快捷方式放到C:\\Users\\用户\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup即可实现。(AppData文件夹在windows中是默认隐藏的) 二、解决方案：Linux在启动时，会自动执行/etc/rc.d目录下的初始化程序，因此我们可以把启动任务放到该目录下。 测试环境：CentOS，管理员:root，普通用户：test1，脚本文件放在/home/test1中， 脚本名：test.py 1.因为其中的rc.local是在完成所有初始化之后执行，因此我们可以把启动脚本写到里面2.用root账号登陆Linux，vim /etc/rc.d/rc.local编辑文件，在最后加入两行需要执行的脚本程序： cd /home/test1 (该步不可少，否则会提示没有权限打开&#39;test.log&#39;文件) su test1 -c &quot;python /home/test1/test.py&quot; (把要执行的命令作为一个参数传递级su) 三、测试：重新启动机器，测试一下，是不是python脚本已经自动运行起来了呢！","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.lovebear.top/tags/Linux/"},{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"}]},{"title":"OCR--基于字符训练方法","date":"2017-01-01T13:18:26.814Z","path":"2017/01/01/CTF_OCR_Training/","text":"一、前言：最近做了一道关于OCR的题，看到图片中的文字（数字）都非常清晰，第一时间想到了使用pytesser，但是在写完代码后，发现并不能识别出来，本来pytesser的识别率就不是很高。后来发现这些数字还有一个规律，相同的数字基本都是一个样式的，于是，想到了字符训练的方法，即，分离出每个字符，再将其他图片中的文字与之匹配的方法。 原题目是计算图片中的数乘以图片名字并相加，得出最终结果。图片文件链接 提取码： o9tn原题目链接 二、字符训练：寻找0-9的特征，截出10个特征 #-*- encoding: utf-8 -*- from PIL import Image box1 = (0,0,6,10) #分成四个格子 box2 = (10,0,16,10) box3 = (20,0,26,10) box4 = (30,0,36,10) def openim(path): return Image.open(path) #训练0-9数字图片 img0 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\1.bmp&#39;) i0 = img0.crop(box2) i0.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\0.bmp&#39;) img1 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\2.bmp&#39;) i1 = img1.crop(box4) i1.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\1.bmp&#39;) img2 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\1.bmp&#39;) i2 = img2.crop(box4) i2.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\2.bmp&#39;) img3 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\3.bmp&#39;) i3 = img3.crop(box3) i3.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\3.bmp&#39;) img4 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\13.bmp&#39;) i4 = img4.crop(box2) i4.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\4.bmp&#39;) img5 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\3.bmp&#39;) i5 = img5.crop(box1) i5.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\5.bmp&#39;) img6 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\1.bmp&#39;) i6 = img6.crop(box3) i6.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\6.bmp&#39;) img7 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\1.bmp&#39;) i7 = img7.crop(box1) i7.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\7.bmp&#39;) img8 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\3.bmp&#39;) i8 = img8.crop(box4) i8.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\8.bmp&#39;) img9 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\7.bmp&#39;) i9 = img9.crop(box3) i9.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\9.bmp&#39;) 三、根据训练结果匹配：#-*- encoding: utf-8 -*- from PIL import Image def openim(path): #打开图片 return Image.open(path) def print1(im): width = im.size[0] #获得像素点集合（作为识别标识） height = im.size[1] pix = im.load() result = [] for x in range(width): for y in range(height): result.append(pix[x,y]) return result def convert1(img): img = img.convert(&quot;L&quot;) #灰度化 WHITE, BLACK = 255, 0 img = img.point(lambda x: WHITE if x &gt;= 230 else BLACK) #有颜色的地方全部变黑 img = img.convert(&#39;1&#39;) return img def cut(img): box1 = (0,0,6,10) #裁剪成4个盒子训练，box中是坐标 box2 = (10,0,16,10) box3 = (20,0,26,10) box4 = (30,0,36,10) im1 = img.crop(box1) im2 = img.crop(box2) im3 = img.crop(box3) im4 = img.crop(box4) return im1,im2,im3,im4 def OCR(img): #把4个数字分开，分别进行匹配 test1 = convert1(img) im1,im2,im3,im4 = cut(test1) result = [] for i in range(10): if print1(im1) == font[i]: result.append(str(i)) for i in range(10): if print1(im2) == font[i]: result.append(str(i)) for i in range(10): if print1(im3) == font[i]: result.append(str(i)) for i in range(10): if print1(im4) == font[i]: result.append(str(i)) return int(&#39;&#39;.join(result)) def getfont(): #训练 font = [] path = &#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\&#39; name = r&#39;.bmp&#39; for i in range(10): im = openim(path+str(i)+name) font.append(print1(convert1(im))) return font font = getfont() path = &#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\&#39; sum = 0 for i in range(1,10000): #根据训练结果匹配得数字 img = openim(path+str(i)+&#39;.bmp&#39;) sum+=i*int(OCR(img)) print &#39;sum =&#39;+str(sum)","tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"XX-NET简介及安装","date":"2017-01-01T11:02:05.989Z","path":"2017/01/01/XX-NET/","text":"一、前言：很多同学都很想翻墙，去浏览一些国外的网站，比如facebook，twitter，youtube，google什么的。当然国内有很多“替代品”，但是，讲道理，还是这些国外的经典网站比较全。下面来介绍一款非常稳定的翻墙利器–XX-NET 二、简单介绍：原来大多数人都使用GoAgent插件来“翻墙”，但是自从GoAgent被和谐掉后，涌现的大批其他插件都达不到理想的效果。于是，出现了XX-NET这一翻墙神器。我们可以认为是GoAgent的后代产物 三、特性： 集成GoAgent、GoGoTest等自动扫描IP，省事省力； Web界面，人性化交互，傻瓜易用； 内置了公共 appid, 方便新手； 方便易用的细节、细节提示； 主要支持浏览器： Chrome， Firefox 四、使用方法：这里直接贴出XX-NET的Github中文安装下载文档，其中图文并全，讲的详细而且准确，这里只是简单介绍这款翻墙利器，安装及下载请参考下面链接。 XX-NET Github中文安装及使用文档 五、注意：XX-NET只是浏览器的一个插件，所以实现的是网站翻墙浏览，即，你可以浏览一些国外的网站，如youtube（亲测不卡），google什么的。如果你先玩国外的游戏，那你还是需要购买相应的vpn，并购买加速器。","tags":[{"name":"翻墙","slug":"翻墙","permalink":"http://www.lovebear.top/tags/翻墙/"}]},{"title":"Python unexpected indent 解决","date":"2017-01-01T06:30:16.427Z","path":"2017/01/01/python_indent_err/","text":"一、前言：python中最常见的错误就是unexpected indent错误了，经常检查发现代码没什么问题，但是就是不知道哪儿错了，提示错误如下： IndentationError: unexpected indent 其实就是缩进问题，缩进中有的地方用了tab，有的地方用了space，很多时候排查不方便，本文提供一个直观的办法解决 二、解决方案：本文使用notepad++文本编辑器，其他文本编辑器自行百度相似的方法 notepad++菜单栏选择 view(视图)--&gt;Show Symbol(显示符号)--&gt;Show White Space and Tab(显示空格和制表符) 这样在代码中会直观的显示出tab和space，只要保证缩进中都是统一的符号（不能space和tab一起用，只能用俩者的一种），错误就可以解决。","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"}]},{"title":"Notepad++配置python环境","date":"2016-12-15T00:27:34.350Z","path":"2016/12/15/notepad++ And python/","text":"一、前言：python是比较轻量级的，但是一些IDE为python集成了许多插件，造成其很大（如python xy），今天我们可以在文本编辑器中（本文使用notepad++）连接python,还原轻巧的python。 二、前期准备：1.python下载（最好是python 2.7版本）：python的msi也就十几M，下载很快，下载完双击安装即可（注意，记住自己的python安装目录） 下载传送门 2.环境变量配置:环境变量的配置是为了让大家在任何位置输入python时，操作系统都会自动寻找到python的位置，并运行它。把刚才安装的python目录加入到系统环境变量中。 3.任意一款文本编辑器这里推荐两款： Notepad++: 下载传送门 Sublime: 下载传送门PS. 此处给出的下载版本都是官网版本，sublime Text 3正版会收费，大家可以自行在网上找破解版。PS. 本文使用notepad++ 三、配置notepad++： 点击notepad++上部菜单栏的run–&gt;run，出现弹窗（或直接按F5） 输入 cmd /k 你的python安装目录\\python “$(FULL_CURRENT_PATH)” &amp; PAUSE &amp; EXIT 比如我的安装目录为E：\\python27 点击save，为python运行设置快捷键（注意，不能与notepad++内部热键冲突，我的是ctrl+F5） 四、测试notepad++中新建一个文档，输入print 1，保存，ctrl+F5运行，是不是就运行出结果了呢！","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"}]},{"title":"Pacman_project1代码及解析","date":"2016-12-13T13:37:20.392Z","path":"2016/12/13/Pacman_project1_code/","text":"一、前言：初学人工智能，感到非常好玩，老师留了一个Pacman Project，经查阅，伯克利大学的人工智能课程也用这个Project作为实验教材。为了方便同学们，我写了Project 1——search的代码，并对每行代码进行详细的注释解析。（网上有别人写好的代码，但是很乱，而且没有注释。。。） 二、进入正题：1.问题1：应用深度优先算法找到一个特定的位置的豆你的code应该能顺利解决以下问题：python pacman.py -l tinyMaze -p SearchAgentpython pacman.py -l mediumMaze -p SearchAgentpython pacman.py -l bigMaze -z .5 -p SearchAgent 废话不多说，直接上代码加注释 def graphSearch(problem, fringe): pgss=problem.getStartState() #获取problem的初始状态 print &quot;Start:&quot;, pgss #打印problem的初始状态 print &quot;Is the start a goal?&quot;, problem.isGoalState(pgss) #判断初始状态是目标状态吗 print &quot;Start&#39;s successors:&quot;, problem.getSuccessors(pgss) #打印初始状态的子状态（与这一状态连接的可达状态） visited = [] #记录这个状态是否访问过，访问过的状态都被添加到visited列表里 fringe.push([(pgss, &quot;Stop&quot; , 0)]) #向数据及结构（依fringe定义的数据结构而定）压入初始状态三元组构成 #的访问路径，三元组元素分别为状态，方向，访问步数 while not fringe.isEmpty(): #数据结构不为空一直循环 path = fringe.pop() #将数据弹出一个（栈顶，队首...）路径 s = path[len(path)-1] #取得路径末的三元组（及访问路径中最后一个状态所在的三元组） s = s[0] #取得本路径的最后状态 if problem.isGoalState(s): #如果取得的这最后一个状态就是我们的目标状态，则搜索结束 return [x[1] for x in path][1:] #返回路径中所有的方向（除去初始状态的方向） if s not in visited: #如果这个状态还没被访问过 visited.append(s) #访问这个状态，并将这个状态添加到访问记录列表visited[]中 for successor in problem.getSuccessors(s): #遍历现状态的子状态 if successor[0] not in visited: #子状态没有被访问过 successorPath = path[:] #创建新的子状态路径（复制当前状态的路径），此处的[:] #为了防止python的引用处理，这样可以真正创建新的路径 successorPath.append(successor)#在原状态路径后面添加上当前访问的子状态，得到新的状态路径 fringe.push(successorPath) #将新的状态路径压入数据结构中 return [] def depthFirstSearch(problem): &quot;&quot;&quot; Search the deepest nodes in the search tree first. Your search algorithm needs to return a list of actions that reaches the goal. Make sure to implement a graph search algorithm. To get started, you might want to try some of these simple commands to understand the search problem that is being passed in: print &quot;Start:&quot;, problem.getStartState() print &quot;Is the start a goal?&quot;, problem.isGoalState(problem.getStartState()) print &quot;Start&#39;s successors:&quot;, problem.getSuccessors(problem.getStartState()) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; fringe = util.Stack() #fringe数据结构为栈，进行dfs return graphSearch(problem, fringe) 2.问题2：宽度优先算法python pacman.py -l mediumMaze -p SearchAgent -a fn=bfspython pacman.py -l bigMaze -p SearchAgent -a fn=bfs -z .5 def breadthFirstSearch(problem): &quot;&quot;&quot;Search the shallowest nodes in the search tree first.&quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; fringe = util.Queue() #fringe数据结构为队列，进行bfs return graphSearch(problem, fringe) 3.问题3：宽度优先算法（代价一致算法）python pacman.py -l mediumMaze -p SearchAgent -a fn=ucspython pacman.py -l mediumDottedMaze -p StayEastSearchAgentpython pacman.py -l mediumScaryMaze -p StayWestSearchAgent def uniformCostSearch(problem): &quot;&quot;&quot;Search the node of least total cost first.&quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; cost = lambda aPath: problem.getCostOfActions([x[1] for x in aPath]) #计算出每条路径的总代价，通过总代价 #作为优先级进行搜索 fringe = util.PriorityQueueWithFunction(cost) #fringe数据结构为优先队列 return graphSearch(problem, fringe) 4.问题4：A* 算法python pacman.py -l bigMaze -z .5 -p SearchAgent -a fn=astar,heuristic=manhattanHeuristic def nullHeuristic(state, problem=None): &quot;&quot;&quot; A heuristic function estimates the cost from the current state to the nearest goal in the provided SearchProblem. This heuristic is trivial. &quot;&quot;&quot; return 0 def aStarSearch(problem, heuristic=nullHeuristic): &quot;&quot;&quot;Search the node that has the lowest combined cost and heuristic first.&quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; cost = lambda aPath: problem.getCostOfActions([x[1] for x in aPath]) + heuristic(aPath[len(aPath)-1][0], problem) fringe = util.PriorityQueueWithFunction(cost) #A*是对代价一致搜索算法的改进，加入了一个估计代价h return graphSearch(problem, fringe) 5.问题5：找到所有的角落python pacman.py -l tinyCorners -p SearchAgent -a fn=bfs,prob=CornersProblempython pacman.py -l mediumCorners -p SearchAgent -a fn=bfs,prob=CornersProblem def getStartState(self): &quot;&quot;&quot; Returns the start state (in your state space, not the full Pacman state space) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; return (self.startingPosition, [self.corners[0], self.corners[1], self.corners[2], self.corners[3]]) #agent初始状态的位置，和四个角落的豆的位置 def isGoalState(self, state): &quot;&quot;&quot; Returns whether this search state is a goal state of the problem. &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; return len(state[1]) == 0 #state[0]为当前agent位置， state[1]为还没吃到的点的位置，state[1]为 #空时，结束为终止位置 def getSuccessors(self, state): &quot;&quot;&quot; Returns successor states, the actions they require, and a cost of 1. As noted in search.py: For a given state, this should return a list of triples, (successor, action, stepCost), where &#39;successor&#39; is a successor to the current state, &#39;action&#39; is the action required to get there, and &#39;stepCost&#39; is the incremental cost of expanding to that successor &quot;&quot;&quot; successors = [] for action in [Directions.NORTH, Directions.SOUTH, Directions.EAST, Directions.WEST]: # Add a successor state to the successor list if the action is legal # Here&#39;s a code snippet for figuring out whether a new position hits a wall: # x,y = currentPosition # dx, dy = Actions.directionToVector(action) # nextx, nexty = int(x + dx), int(y + dy) # hitsWall = self.walls[nextx][nexty] &quot;*** YOUR CODE HERE ***&quot; x,y = state[0] #获取agent当前位置 dx, dy = Actions.directionToVector(action) nextx, nexty = int(x + dx), int(y + dy) #下一个位置坐标 hitsWall = self.walls[nextx][nexty] #判断是否撞到墙 if not hitsWall: #判断，没撞到墙 nextPosition = (nextx, nexty) #下个位置坐标 cornersLeft = state[1][:] #复制当前剩余没吃到的点 if nextPosition in cornersLeft: #如果下个坐标在剩余没吃到的点中 cornersLeft.remove(nextPosition) #因为下一个就能把它吃掉，所以把这个点从剩余 #没吃到点的列表中删除 nextState = (nextPosition, cornersLeft) #计算下一个点的坐标 cost = 1 #代价为1，（步数为1） successors.append( ( nextState, action, cost) ) #属于可达的子状态，加入到子状态列表 self._expanded += 1 # DO NOT CHANGE return successors 6.问题6：角落问题（启发式）python pacman.py -l mediumCorners -p AStarCornersAgent -z 0.5 def cornersHeuristic(state, problem): &quot;&quot;&quot; A heuristic for the CornersProblem that you defined. state: The current search state (a data structure you chose in your search problem) problem: The CornersProblem instance for this layout. This function should always return a number that is a lower bound on the shortest path from the state to a goal of the problem; i.e. it should be admissible (as well as consistent). &quot;&quot;&quot; corners = problem.corners # These are the corner coordinates walls = problem.walls # These are the walls of the maze, as a Grid (game.py) &quot;*** YOUR CODE HERE ***&quot; heuristic = 0 cornersLeft = state[1][:] #剩余点的坐标 referencePoint = state[0] #当前点的坐标 while len(cornersLeft) &gt; 0: #当有点剩余（未吃完所有点） closestCorner = closestPoint(referencePoint, cornersLeft) #当前点坐标和未吃到点中的哪一个离得最近 heuristic += euclidieanDistance(referencePoint, closestCorner) #估计值h加上当前点到最近未吃点的距离 referencePoint = closestCorner #当前点变为最近未吃点，因为已经走到了那个点 cornersLeft.remove(closestCorner) #从未吃点列表中将刚才吃掉的点删除 return heuristic #return 0 # Default to trivial solution def closestPoint (fromPoint, candidatesList): if len(candidatesList) == 0: #如果未吃点列表为空，证明所有点都被吃了，返回none return None closestCorner = candidatesList[0] #获取未吃点列表中的第一个点 closestCost = euclidieanDistance(fromPoint, closestCorner) #计算当前点到第一个点距离 for candidate in candidatesList[1:]: thisCost = euclidieanDistance(fromPoint, candidate) if closestCost &gt; thisCost: #循环遍历列表，返回距当前点最近的一个未吃点的坐标 closestCost = thisCost closestCorner = candidate return closestCorner def euclidieanDistance (pointA, pointB): return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])#因为坐标为表格化，不能斜着走，所以最短距离为|x|+|y| 7.问题7：吃掉所有的豆子（这个程序有点卡，稍等一会）python pacman.py -l testSearch -p AStarFoodSearchAgentpython pacman.py -l trickySearch -p AStarFoodSearchAgent def foodHeuristic(state, problem): &quot;&quot;&quot; Your heuristic for the FoodSearchProblem goes here. This heuristic must be consistent to ensure correctness. First, try to come up with an admissible heuristic; almost all admissible heuristics will be consistent as well. If using A* ever finds a solution that is worse uniform cost search finds, your heuristic is *not* consistent, and probably not admissible! On the other hand, inadmissible or inconsistent heuristics may find optimal solutions, so be careful. The state is a tuple ( pacmanPosition, foodGrid ) where foodGrid is a Grid (see game.py) of either True or False. You can call foodGrid.asList() to get a list of food coordinates instead. If you want access to info like walls, capsules, etc., you can query the problem. For example, problem.walls gives you a Grid of where the walls are. If you want to *store* information to be reused in other calls to the heuristic, there is a dictionary called problem.heuristicInfo that you can use. For example, if you only want to count the walls once and store that value, try: problem.heuristicInfo[&#39;wallCount&#39;] = problem.walls.count() Subsequent calls to this heuristic can access problem.heuristicInfo[&#39;wallCount&#39;] &quot;&quot;&quot; position, foodGrid = state &quot;*** YOUR CODE HERE ***&quot; foodList = foodGrid.asList() #得到要吃的点的列表（未吃点列表） if len(foodList) == 0: #当未吃点列表为空时，停止 return 0 closestFood = closestPoint(position, foodList) #得到离当前点最近的未吃食物 return euclidieanDistance(position, closestFood) + len(foodList) 8.问题8：次最优搜索python pacman.py -l bigSearch -p ClosestDotSearchAgent -z .5 class ClosestDotSearchAgent(SearchAgent): &quot;Search for all food using a sequence of searches&quot; def registerInitialState(self, state): self.actions = [] currentState = state while(currentState.getFood().count() &gt; 0): nextPathSegment = self.findPathToClosestDot(currentState) # The missing piece self.actions += nextPathSegment for action in nextPathSegment: legal = currentState.getLegalActions() if action not in legal: t = (str(action), str(currentState)) raise Exception, &#39;findPathToClosestDot returned an illegal move: %s!\\n%s&#39; % t currentState = currentState.generateSuccessor(0, action) self.actionIndex = 0 print &#39;Path found with cost %d.&#39; % len(self.actions) def findPathToClosestDot(self, gameState): &quot;&quot;&quot; Returns a path (a list of actions) to the closest dot, starting from gameState. &quot;&quot;&quot; # Here are some useful elements of the startState startPosition = gameState.getPacmanPosition() food = gameState.getFood() walls = gameState.getWalls() problem = AnyFoodSearchProblem(gameState) &quot;*** YOUR CODE HERE ***&quot; return search.aStarSearch(problem,search.nullHeuristic) #A*搜索 class AnyFoodSearchProblem(PositionSearchProblem): &quot;&quot;&quot; A search problem for finding a path to any food. This search problem is just like the PositionSearchProblem, but has a different goal test, which you need to fill in below. The state space and successor function do not need to be changed. The class definition above, AnyFoodSearchProblem(PositionSearchProblem), inherits the methods of the PositionSearchProblem. You can use this search problem to help you fill in the findPathToClosestDot method. &quot;&quot;&quot; def __init__(self, gameState): &quot;Stores information from the gameState. You don&#39;t need to change this.&quot; # Store the food for later reference self.food = gameState.getFood() # Store info for the PositionSearchProblem (no need to change this) self.walls = gameState.getWalls() self.startState = gameState.getPacmanPosition() self.costFn = lambda x: 1 self._visited, self._visitedlist, self._expanded = {}, [], 0 # DO NOT CHANGE def isGoalState(self, state): &quot;&quot;&quot; The state is Pacman&#39;s position. Fill this in with a goal test that will complete the problem definition. &quot;&quot;&quot; x,y = state &quot;*** YOUR CODE HERE ***&quot; return self.food[x][y] #state为终点坐标 三、总结：这东西还是挺好玩的，希望本文对大家有用","tags":[{"name":"pacman","slug":"pacman","permalink":"http://www.lovebear.top/tags/pacman/"}]},{"title":"Ubuntu Python 默认使用版本改变","date":"2016-12-11T01:29:35.966Z","path":"2016/12/11/Ubuntu-Python_Version/","text":"一、前言：ubuntu 14系统的初始默认python版本为python 2.7.6，也就是说，当我们输入 python 运行程序 ubuntu默认使用python 2.7.6而当我们想用python3运行程序时，必须用 python3 运行程序 怎么使python命令自动使用python3以上的版本运行程序呢？ 二、解决方案：只需要打开终端，输入 echo alias python=python3 &gt;&gt; ~/.bashrc source ~/.bashrc 就可以完成改变 三、测试这时，输入 python 运行程序 就可以以python3的版本运行程序啦 四、注意笔者不是很建议这样做，可能会引起不必要的麻烦，但是特殊情况需要用到这种方式。","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.lovebear.top/tags/ubuntu/"}]},{"title":"Hexo Your Blog","date":"2016-10-08T12:24:30.365Z","path":"2016/10/08/Hexo-Your-Blog/","text":"一、前言：之前逛一位ctf大神的博客，偶然发现这个Hexo，了解一下，还真是好东西，既能提高技能，又能装逼（qwq这是重点），网上的大多数教程都是大同小异，完全按照那个来搭建会失败，本文图文教程，让小白也能成功搭建起属于自己的专属Blog。 二、前期准备：1.Git：一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 下载传送门【需要翻墙】 百度云链接【提取码：3hu4】 2.Node.js:一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。 下载传送门 百度云链接【提取码：siy6】 3.任意一款文本编辑器这里推荐两款： Notepad++: 下载传送门 Sublime: 下载传送门PS. 此处给出的下载版本都是官网版本，sublime Text 3正版会收费，大家可以自行在网上找破解版。 三、配置GitHub：1. 注册GitHub账号2. 配置SSH keysPS. 命令行指令win+R打开运行窗口，输入cmd，回车，打开shell 1)检查SSH keys设置$ cd ~/. ssh 检查本机的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 2)生成新的SSH keys$ ssh-keygen -t rsa -C &quot;youremail&quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; PS. Youremail处填写你自己的邮箱，例如 lovebear@gmail.com 然后系统会要你输入密码： Enter passphrase (empty for no passphrase):&lt;输入加密串&gt; Enter same passphrase again:&lt;再次输入加密串&gt; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。 PS. 输入密码的时候没有*字样的，你直接输入就可以了。 成功生成SSH keys会在C:/User/登录用户名/.ssh产生两个文件id_rsa和id_rsa.pub PS. 登陆用户名为开机时显示的登陆用户名，默认为Administrator 3)添加SSH keys到GitHub在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。 打开生产的id_rsa.pub文件。此文件里面内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。 登陆github。点击右上角的头像 —&gt; Settings—&gt; SSH and GPG keys —&gt; New SSH key 把你id_rsa.pub中的内容（密钥）复制到key文本框中，点击 add SSH key 4)测试是否配置成功输入下面的命令，看看设置是否成功： $ ssh -T git@github.com 出现下图： The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 输入yes Hi cnfeat! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 配置成功 5)设置基本用户信息Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。 $ git config --global user.name &quot;cnfeat&quot;//用户名 $ git config --global user.email &quot;cnfeat@gmail.com&quot;//填写自己的邮箱 至此，SSH keys配置成功。四、GitHub上建立仓库（GitHub Pages）：与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务，GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。 想建立个人博客是用的第一种，形如beiyuu.github.io这样的可访问的站 PS. 每个用户名下面只能建立一个。 1.点击右上角的new Repository,创建仓库 2.填写项目信息 Resporitary name: 填写 你的账号名.github.io，例如我的登陆用户名是cckuailong，建立仓库的名称就是cckuailong.github.io Description: 填写你的仓库描述（随便写点就行） PS. 选中public选项，让大家都可以访问。记得勾选上Initialize this resporitary with a README。 3.点击Create resporitary，完成创建五、安装Git和Node.js：与安装其他软件一样，安装目录可以自选，如果不清楚，就按照默认安装。 六、Hexo Your Blog：1.Hexo简介Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。 2.打开Git找到你安装Git的目录，双击git-bash，或者 右键，在选项中点击git-bash，打开Git命令行。 3.安装Hexo在Git命令行执行下列命令： npm install -g hexo 4.初始化Hexo在你想要部署的位置建立一个新的文件夹（快捷键ctr+shift+n），命名为Hexo。在这个文件夹下，右键，选择git-bash，输入下述命令后，回车： $ hexo init Hexo随后会自动在目标文件夹下载网站所需要的所有文件。 5.生成静态界面执行 $ hexo g 生成静态页面至hexo\\public\\目录。 6.本地启动执行 $ hexo s 进行本地启动。 启动完成后，打开浏览器，输入http://localhost:4000 就可以看到效果，我们的Hexo博客已经搭建起来了。 PS. Ctrl+c停止启动，相当于断开本地启动，http://localhost:4000 将不能被访问，一般本地启动的作用是本地调试，根据博客展示效果，可以及时修改，都修改完毕后，再部署到GitHub上。（下一小节讲解如何将博客部署到GitHub） 七、将博客部署到GitHub：1.部署到GitHub前需要配置_config.yml文件，首先找到下面的内容# Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: 修改为： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: github repository:https://github.com/username/username.github.io.git branch: master PS. 两个Username处替换为自己的GitHub登陆用户名，即上面创建的仓库名。 这里注意，如果你的Hexo是3.0版本，type处的github应该更改为git，才可以部署成功。 2.执行：$ hexo g -d 完成部署。 3.登陆GitHub，打开刚才创建的仓库（Repositary），发现里面多了很多部署好的文件。 PS. 你的文件可能没有404.html和CNAME两个文件，不要急，下面会讲到。 八、DNS与GitHub Pages的绑定：1.什么是DNS？例如，www.baidu.com, www.lovebear.top 这些方便好记的网址就可以认为是DNS了。 2.购买DNS网上大多数推荐GoDaddy，但是我这里推荐百度开放云（上面的域名很便宜啊）传送门在这里 3.DNS设置1)注册DNSpod（速度快，稳定，还免费！！！）2)在左侧选中域名解析，点击，添加域名，输入你刚才购买的域名 3)点击添加成功的域名（这里是lovebear.top），进入到管理你的域名后，点击记录，添加两条记录（一个是@，另一个是www）注意：在添加记录时，会填写记录值，获得你的记录值的方式如下： Win+R打开运行，输入cmd，回车，打开shell，输入 Ping username.github.io 方括号中的ip即为你的记录值，把它填到两个记录中就可以啦。 4)登陆百度开放云，点击域名管理，点击右方的更多操作，选择域名信息 点击修改DNS，修改成图中显示的两个dns 保存 5)打开GitHub，点击Create new file，新建文件名为CNAME，内容是你刚才申请的域名 注意要保存到主干（master） 保存后发现仓库中多了个CNAME文件 至此，DNS设置完成，DNSpod第一次解析域名可能会时间稍长，至多一天，请大家耐心等待吧。九、大功告成：浏览器输入你购买的域名，是不是就成功了呢^_^","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.lovebear.top/tags/hexo/"}]}]