[{"title":"Linux学习笔记--基本命令","date":"2017-02-09T14:19:59.454Z","path":"2017/02/09/Linux_notation/","text":"一、前言：作为一名小白，之前一直非常喜欢使用windows的图形化界面。发现许多大神都在使用Linux的系统，在键盘上敲击各种命令，非常的帅气。最近在windows上安装一些开源软件的时候，发现有的开源软件在Linux下安装使用效果比windows要好，而且自己弄了一台服务器，装的系统也是Linux（CentOS），于是，决定好好的学习一波Linux。 以前不太了解Linux作为服务器的好处，着手学习后，了解到Linux一般作为服务器，都会选用安装字符界面，而不采用图形界面。一是，为了减少服务器的运行压力（图形界面会占一部分存储空间，并且影响运行速度），二是，可以减少出现bug的几率（没有了图形界面，系统变得简单，系统出现内核bug的几率就会大大减少）。看了这么多好处，是时候好好学习一波啦。 二、Linux基本命令：1. 基本命令i. 列举文件ls [选项] -a #全部文件（包括隐藏文件，“.”开头的文件为隐藏文件） -l #详细信息（-：文件 d:目录 l：链接文件）（三个一组，分别为所有者，用户组，其他人的读写权限） ls -l 可以简化为 ll -d #查看目录属性 -h #人性化显示文件大小 -i #显示inode ii. 创建和删除目录创建 mkdir -p [目录名] # -p为递归创建多级目录 删除 rmdir [目录] #删除空目录（不常用，因为只能删除空目录） rm [选项] [文件或目录] -r #删除目录 -f #强制删除 iii. 命令搜索命令whereis [选项] 命令名 #搜索命令所在路径及帮助文档所在位置 -b #只查找可执行文件 -m #只查找帮助文档 which [命令名] #搜索命令所在位置及命令别名 注意： shell自带命令（如 cd）上述指令找不到 2. 文件操作命令i. 文件复制（拷贝）cp [选项] [源文件或目录] [目标目录] -r #复制目录 -p #连带文件属性复制 -d #若源文件为链接文件，则复制链接属性 -a # == -pdr ii. 文件移动（剪切）mv [源文件或目录] [目标目录] #可以用mv命令对文件进行重命名 iii. 链接命令ln [选项] [源文件] [目标文件] -s #创建软链接 NaN #创建硬链接 软链接： 有自己的inode和block，block中存放指向文件的文件名，相当于快捷方式，源文件删除，失效硬链接： 与源文件公用inode和block，源文件删除，硬链接不失效 iv. 文件搜索–locatelocate [文件名] 在后台数据库（/var/lib/mlocate，注意，不同Linux版本，数据库文件名字可能不同）中按文件名搜索，速度非常快mlocate文件大约一天一更新，可用updatedb强制更新updatedb.conf文件的一些参数： PRUNE_BIND_MOUNTS=”yes” #开启搜索限制 PRUNEFS= #搜索时，不搜索的文件系统 PRUNENAMES= #搜索时，不搜索的文件类型 PRUNEPATHS= #搜索时，不搜索的路径 注意： locate只能按文件名搜索 v. 文件搜索–findfind [搜索范围] [搜索条件] #例： find / -name=xxx -iname #不区分大小写 -user #按所有者 -nouser #搜索没有所有者的文件 -mtime +10 #10天前，修改文件内容的文件 -ctime 10 #10天时，改变文件属性的文件 -atime -10 #10天内，文件访问时间 -size +2k(M,G) #大于2k(M,G)的文件 2k(M,G) #等于2k(M,G)的文件 -2k(M,G) #小于2k(M,G)的文件，若无单位则默认单位为扇区数 -inum [inode] #通过i节点找文件 find扩展用法 (1). -a #and，逻辑与，两条件都满足 -o #or， 逻辑或，满足一个条件 例： find /etc -size +20k -a -size -50k #搜索20k~50k的文件 (2). -exec/-ok [命令] {}\\; #找出文件后，对其执行命令 例： find /etc -size +20k -a -size -50k -exec ls -lh {}\\; 3. 搜索字符串命令grep [选项] [字符串] [文件名] #文件中匹配符合条件的字符串 -i #忽略大小写 -v #排除指定字符串 4. 帮助命令man [选项] [命令] -f #查看命令级别，相当于whatis [命令] (man [级别] [命令] #查看这个级别的命令) -k #所有相关命令，相当于apropos [命令] --help #注意，不能使用 -h help [shell命令] #内核命令帮助 例： help cd #判断是否为shell命令，whereis，不出现则为shell命令 info #进入帮助文档（操作繁琐） -enter #进入子帮助界面（*号） -u #进入上层界面 -n #进入下一个帮助小节 -p #进入上一个帮助小节 -q #退出 5. 压缩命令i. zip压缩zip [压缩文件名] [源文件] #压缩文件 zip -r [压缩文件名] [源目录] #压缩目录 unzip [压缩文件] #解压 ii. gz压缩gzip [源文件] #源文消失，新生成的压缩文件加.gz gzip -c [源文件] &gt;[压缩文件] #重定向，源文件保留 例： gzip -c hjj &gt;hjj.gz gzip -r [目录] #目录不压缩，压缩名录中的全部子文件 gzip -d [压缩文件] 或 gungzip [压缩文件] #解压 iii. bz2压缩（不能压缩目录）bzip2 [源文件] #不保留源文件 bzip2 -k [源文件] #保留源文件 bzip2 -d [压缩文件] 或 bunzip2 [压缩文件] #解压，-k保留压缩文件 6. 打包命令tar [选项] [打包文件名] [源文件] -c #打包 -v #显示过程 -f #指定打包后文件名 -x #解打包 例： tar -cvf hjj.tar hjj tar -zcvf [压缩包名] [源文件] -z #打包为.tar.gz -j #打包为.tar.bz2 -C #指定解压位置 例： tar -jxvf hjj.tar.bz2 -C /tmp -t #查看压缩包内容 7. 关机与重启命令shutdown [选项] [时间] -c #取消前一个关机命令 -h #关机 -r #重启 #时间 now代表立即，其他时间格式为00：00 #后台执行，&amp; 关机其他命令 halt init 0 poweroff (不保存数据，不安全) 重启其他命令 reboot(可用，安全) init 6 8. 挂载命令i. 查询与自动挂载mount #查询已挂载设备 mount -a #依据配置文件/etc/fstab，自动挂载 ii. 挂载命令格式mount [-t 文件系统] [-o 特殊选项] [设备文件名] [挂载点] -t 文件系统： 加入文件系统类型来指定挂载类型，ext3,ext4,iso9660(光盘)等文件系统 -o 特殊选项： 可指定挂载的额外选项 iii. 挂载光盘mkdir /mnt/cdrom #建立挂载点 mount -t iso9660 /dev/sr0 /mnt/cdrom #会出现光盘只读警告，不影响挂载 iv. 卸载命令umount [设备文件名或挂载点] 例： umount /dev/sr0 或 umount /mnt/cdrom 注意： 不能在光盘目录中umount，提示busy v. 挂载u盘fdisk -l #查看u盘设备文件名 mount -t vfat /dev/sdb1 /mnt/usb1 注意： vfat指fat32文件系统，Linux默认不支持NTFS文件系统 9. 用户登录查看w 或 who #查看用户登录信息（w命令查看的更多） last #查询当前登陆和过去登陆的用户信息，读取/var/log/wtmp文件 lastlog #查看所有用户最后一次登录时间，读取/var/log/lastlog文件 10. 输出命令echoecho [选项] [输出内容] -e #支持&quot;\\&quot;控制的字符转换 | 控制字符 | 作用 ||：———：|:——————:|| \\a |警告音 || \\b |退格 || \\n |换行 || \\r |回车 || \\t |tab || \\v |垂直tab || \\0nnn |8进制ascii码表输出 || \\xhhh |16进制ascii码表输出 | 开启颜色显示 \\e[1;31m 关闭颜色显示 \\e[0m #30m=黑色 31m=红色 32m=绿色 33m=黄色 34m=蓝色 35m=洋红 36m=青色 37m=白色 11. 命令别名alias #查看已定义的命令别名 alias [别名]=&quot;命令&quot; #赋予别名（重启即失效） 注意： 要想使别名永久生效，需vi ~/.bashrc，写入环境变量配置文件（每个用户一个） 重登录后永久生效 unalias #临时删除别名 12. 历史命令history [选项] [历史命令保存文件] -c #清空历史命令 -w #缓存中历史命令写入历史命令保存文件~/.bash_history 历史命令默认保存1000条，可在环境变量配置文件/etc/profile的HISTSIZE选项修改 !n #执行第n条命令 !! #执行上一条命令 !字串 #执行最后一条以该字串开头的命令 13. 重定向i. 正确输出和错误输出同时保存[命令] &gt;&gt;[文件] 2&gt;&amp;1 #输出到同一文件 [命令] &amp;&gt;&gt;[文件] #输出到同一文件 [命令] &gt;&gt;[文件1] 2&gt;&gt;[文件2] #正确输出到文件1，错误输出到文件2 ii. 输入重定向[命令] &lt; [文件] #文件作为命令输入 [命令] &lt;&lt; [标识符] #把标识符之间内容作为命令输入 14. 统计字符wc [选项] [文件名] -c #统计字节数 -w #统计单词数 -l #统计行数","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.lovebear.top/tags/Linux/"}]},{"title":"CTF--BMP文件的LSB题型","date":"2017-02-03T04:54:14.369Z","path":"2017/02/03/CTF_BMP_LSB/","text":"一、前言：我在之前的Blog中介绍了BMP的格式，而在隐写领域，经常利用LSB技术将信息隐藏在BMP格式的文件中。这里通过一道具体的题目来介绍，并且使用python编写代码，以后的题型都可以套用这个代码。 原题目链接 二、原题：hint： 二战胜利后的亲吻！女主的腰下的好低！真的很低！最低位了！ 三、python代码：# -*- coding: utf8 -*- #最低位的亲吻 from PIL import Image def foo(): im=Image.open(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\01.bmp&#39;) im2=im.copy() pix=im2.load() #加载bmp图片的数据区 width,height=im2.size for x in xrange(0,width): for y in xrange(0,height): #LSB if pix[x,y]&amp;0x1==0: #获取最后一位 pix[x,y]=0 #黑 else: pix[x,y]=255 im2.show() pass if __name__ == &#39;__main__&#39;: foo() print &#39;ok&#39; pass","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"},{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"IMG格式--BMP文件格式解析","date":"2017-02-03T01:48:03.536Z","path":"2017/02/03/IMG_BMP_Format/","text":"一、前言：这两天遇到了许多关于bmp隐藏信息（最低位隐藏）的问题，在解决问题的过程中，我发现BMP格式的图片可以细分为很多种，就决定将BMP文件详细的研究一下，查阅了一些资料进行整理，在这里进行记录。 二、简单介绍：BMP文件格式，又称为Bitmap（位图）或是DIB(Device-Independent Device，设备无关位图)，是Windows系统中广泛使用的图像文件格式。由于它可以不作任何变换地保存图像像素域的数据，因此成为我们取得RAW数据的重要来源。Windows的图形用户界面（graphical user interfaces）也在它的内建图像子系统GDI中对BMP格式提供了支持。 注意： BMP文件采用小尾顺序进行记录（即低地址村存放低位数据，高地址存放高位数据） 三、BMP格式结构： 数据段名称 对应的Windows结构体 大小(byte) BMP文件头 BITMAPFILEHEADER 14 位图信息头 BITMAPINFOHEADER 40 调色板 颜色索引数决定 位图数据 图像尺寸决定 bmp文件头(bmp file header)： 文件的格式、大小等信息 位图信息头(bitmap information)： 图像数据的尺寸、位平面数、压缩方式、颜色索引等信息 调色板(color palette)： 可选，如使用索引来表示图像，调色板就是索引与其对应的颜色的映射表 位图数据(bitmap data)： 图像数据 注意： 我们一般见到的图像以24位图像为主，即R、G、B三种颜色各用8个bit来表示，这样的图像我们称为真彩色，这种情况下是不需要调色板的，也就是所位图信息头后面紧跟的就是位图数据了。因此，我们常常见到有这样一种说法：位图文件从文件头开始偏移54个字节就是位图数据了，这其实说的是24或32位图的情况。这也就解释了我们按照这种程序写出来的程序为什么对某些位图文件没用了。 四、各数据段详解：BMP文件头typedef struct tagBITMAPFILEHEADER { UINT16 bfType; DWORD bfSize; UINT16 bfReserved1; UINT16 bfReserved2; DWORD bfOffBits; } BITMAPFILEHEADER; 变量名 地址偏移 大小(byte) 作用 bfType 0000H 2 文件类型，取值：● BM – Windows● BA – OS/2 Bitmap Array● CI – OS/2 Color Icon● CP – OS/2 Color Pointer● IC – OS/2 Icon● PT – OS/2 Pointer bfSize 0002H 4 说明该位图文件的大小，以字节为单位 bfReserved1 0006H 2 保留 bfreserved2 0008H 2 保留 bfOffBits 000AH 4 说明从文件头开始到实际图像数据间字节的偏移（一般通过这种方式找到位图数据） 位图信息头typedef struct tagBITMAPINFOHEADER { DWORD biSize; DWORD biWidth; DWORD biHeight; UINT16 biPlanes; UINT16 biBitCount; DWORD biCompression; DWORD biSizeImage; DWORD biXPelsPerMeter; DWORD biYPelsPerMeter; DWORD biClrUsed; DWORD biClrImportant; } BITMAPINFOHEADER; 变量名 地址偏移 大小(byte) 作用 biSize 000EH 4 BITMAPINFOHEADER结构所需要的字节数 biWidth 0012H 4 说明图像的宽度，像素为单位 biHeight 0016H 4 说明图像的高度，像素为单位注：biHeight还用来指明该图像是倒向位图（正数）还是正向（负数）位图 biPlanes 001AH 2 说明颜色平面数，总为1 biBitCount 001CH 2 说明比特数/像素，值为1、4、8、16、24、32 biCompression 001EH 4 说明图像数据压缩的类型：● 0 – BI_RGB 不压缩（最常用）● 1 – BI_RLE8 8比特游程编码(RLE)，只用于8位位图● 2 – BI_RLE4 4比特游程编码(RLE)，只用于4位位图● 3 – BI_BITFIELDS 比特域，用于16/32位位图● 4 – BI_JPEG JPEG 位图含JPEG图像(仅用于打印机)● 5 – BI_PNG PNG 位图含PNG图像(仅用于打印机) biSizeImage 0022H 4 图像大小，字节为单位（BI_RGB时，可设置为0） biXPelsPerMeter 0026H 4 水平分辨率，用像素/米表示，有符号整数，0为默认设置 biYPelsPerMeter 002AH 4 垂直分辨率，用像素/米表示，有符号整数，0为默认设置 biClrUsed 002EH 4 位图实际使用彩色表中颜色索引（0值表示适用所有调色板项） biClrImportant 0032H 4 对图像显示有重要影响的颜色索引的数目（0值表示都重要） 调色板下面的数据就是调色板了。前面也已经提过，调色板其实是一张映射表，标识颜色索引号与其代表的颜色的对应关系。它在文件中的布局就像一个二维数组palette[N][4],其中N表示总的颜色索引数，每行的四个元素分别表示该索引对应的B、G、R和Alpha的值，每个分量占一个字节。如不设透明通道时，Alpha为0。因为前面知道，本图有256个颜色索引，因此N = 256。索引号就是所在行的行号，对应的颜色就是所在行的四个元素。 位图数据每个像素占的字节数取决于biBitCount的值，如果biBitCount=8，像素值代表颜色索引值，如果biBitCount=24、32，则位图数据区就不是索引，而是实际的像素值。24位RGB按照BGR的顺序来存储每个像素的各颜色通道的值，一个像素的所有颜色分量值都存完后才存下一个下一个像素，不进行交织存储。32位数据按照BGRA的顺序存储，其余与24位位图的方式一样。 如果位图信息中图像高度是正数，位图数据排列为，从图像的左下角到图像的右上角，并且以行为主序。 五、对齐规则：讲完了像素的排列规则以及各像素的颜色分量的排列规则，最后我们谈谈数据的对齐规则。我们知道Windows默认的扫描的最小单位是4字节，如果数据对齐满足这个值的话对于数据的获取速度等都是有很大的增益的。因此，BMP图像顺应了这个要求，要求每行的数据的长度必须是4的倍数，如果不够需要进行比特填充（以0填充），这样可以达到按行的快速存取。这时，位图数据区的大小就未必是 图片宽×每像素字节数×图片高 能表示的了，因为每行可能还需要进行比特填充。 六、嵌入式平台BMP格式嵌入式平台BMP格式在调色板数据段与PC机的不同，如在嵌入式平台上常见的16位r5g6b5位图实际上采用的掩模的方式而不是索引的方式来表示图像。此时，在调色板数据段共有四个部分，每个部分为四个字节，实际表示的是彩色版规范。即： 第一个部分是红色分量的掩模 第二个部分是绿色分量的掩模 第三个部分是蓝色分量的掩模 第四个部分是Alpha分量的掩模（缺省为0） 典型的调色板规范在文件中的顺序为为： 00F8 0000 E007 0000 1F00 0000 0000 0000 其中 00F8 0000 为 FB00h=1111100000000000（二进制），是蓝红分量的掩码。 E007 0000 为 07E0h=0000011111100000（二进制），是绿色分量的掩码。 1F00 0000 为 001Fh=0000000000011111（二进制），是蓝色分量的掩码。 0000 0000 设置为0。 将掩码跟像素值进行“与”运算再进行移位操作就可以得到各色分量值。看看掩码，就可以明白事实上在每个像素值的两个字节16位中，按从高到低取5、6、5位分别就是r、g、b分量值。取出分量值后把r、g、b值分别乘以8、4、8就可以补齐每个分量为一个字节，再把这三个字节按BGR组合，放入存储器，就可以转换为24位标准BMP格式了。 这样我们假设在位图数据区有一个像素的数据在文件中表示为02 F1。这个数据实际上应为F102： r = (F102 AND F800) &gt;&gt; 8 = F0h = 240 g = (F102 AND 07E0) &gt;&gt; 3 = 20h = 32 b = (F102 AND 001F) &lt;&lt; 3 = 10h =16 至此我们就可以显示了。","tags":[{"name":"image","slug":"image","permalink":"http://www.lovebear.top/tags/image/"}]},{"title":"CTF--大数因子求和与大数模运算","date":"2017-02-01T13:27:36.911Z","path":"2017/02/01/CTF_FactorSum/","text":"一、前言：在实验吧遇到一道看起来很简单的题，其实有很多内容在其中，这道题包括大数的全部因子求和，并且穿插了大数模运算的技巧。 原题目链接 二、原题：求12345^12345的所有约数（即因子）之和，并对其取模9901再输出。 三、分析：注意： 首先明确一点初中的知识，一个数的因子包括1和这个数本身 质因数分解12345，可以自己写脚本，也可以直接在线分解，提供一个在线质因数分解网站：http://www.atool.org/quality_factor.php得到12345 = 3 5 823 12345^12345 = 3^12345 + 5^12345 + 823^12345 12345^12345的因子和可以化为（3^0+3^1+3^2….+3^12345）（5^0+5^1+5^2….+5^12345）（823^0+823^1+823^2….+823^12345） 根据大数模运算的方法可知(abc)%p==(a%p)(b%p)(c%p)%p可得（3^0%9901+….+3^12345%9901）（5^0%9901+….+5^12345%9901）（823^0%9901+….+823^12345%9901）%9901 也可以进行优化，这里就是提供思想 四、python代码#-*- coding:utf-8 -*- #print 12345**12345 key=12345#12345=3*5*823 sum=0 key1=key2=key3=0 for i in range(0,12346): key1+=3**i%9901 key2+=5**i%9901 key3+=823**i%9901 print (key1*key2*key3)%9901","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"},{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"双基回文数的判断","date":"2017-02-01T05:09:25.111Z","path":"2017/02/01/doublepalidrome/","text":"一、前言：回文数相信大家都不会陌生（设n是一任意自然数。若将n的各位数字反向排列所得自然数n1与n相等，则称n为一回文数，如123321），判断方法的代码也很容易想到，今天要介绍的是一种特殊的回文数–双基回文数 二、双基回文数的定义：如果一个数在至少两种进位制(二进制到十进制)下的表示是回文数,我们就称之为双基回文数.例如，495的二进制表示是111101111,八进制表示是757,这两种进制下的表示都是回文数,所以495就是一个双基回文数. 三、双基回文数的python代码：#进制转换 def change(n,b): #10进制数转为 b 进制 i=0 sum=[] while(1): if(n&lt;b): sum.append(chr(ord(&#39;0&#39;)+n)) i+=1 return sum[::-1] sum.append(chr(n%b+ord(&#39;0&#39;))) i+=1 n/=b #回文(palindrome) def palindrome(s): i=0 while(i&lt;len(s)/2): if(s[i]!=s[-1*(i+1)]): return False i+=1 return True #双基回文（double palindrome） def d_palindrome(n): cnt=0 for i in range(2,10): s=&#39;&#39;.join(change(n,i)) if(palindrome(s)): cnt+=1 if(palindrome(str(n))): cnt+=1 if(cnt&gt;=2): return True else: return False","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"}]},{"title":"素数表的快速创建","date":"2017-01-31T12:52:33.539Z","path":"2017/01/31/GetPrimeList/","text":"一、前言：进入大学第一学期的第一个实验就是，在一定的时间限制内，找出0~2000000的素数，也就是创建一个2000000以内的素数表。普通的素数遍历方式肯定行不通，简单优化（如sqrt(2000000),循环时剔除偶数，等方法）也不见得能通过测试，这里介绍两种进一步优化的算法。 我们知道，要想减少算法的时间复杂度，除了优化算法，另一种必不可少的思想就是“空间换时间”。本文第一种算法是对算法的优化，第二种算法是利用“空间换时间”的思想，使时间复杂度达到最小化。 二、素数表优化算法：1. 算法思想：判断一个数是不是素数的时候，我们经常的做法就是从2遍历到这个数的平方根大小（即2&lt;=i&lt;=sqrt(n)），用 n%i 判断是否等于0，来进行素数判断。对这个算法进行优化，就是需要减少i的个数，来减少循环的次数。那么思考，如果一个合数h作为n（判断n是否为素数）的因子，则n一定不是素数。所以，这里只需要令i为素数（即遍历素表），来计算n%i即可。 2. python代码def isPrime(n,pList): i=0 while(pList[i]&lt;=math.sqrt(n)): if(n%pList[i]==0): return False i+=1 return True #素数表创建 def getPrimeList(num): pList=[2] for i in xrange(3,num,2): if(isPrime(i,pList)): pList.append(i) return pList 三、时间换空间法：1. 算法思想：首先为1到2000000创建一个列表，记录是否被访问过（初始化为0，访问过为1）。一个数为素数，那么它的所有整数倍的数都是合数，将其整数倍的数标记为已访问，这样访问遍历的次数将会大大减少。 2. python代码：def isPrime_f(n): for i in xrange(2,int(math.sqrt(n)),2): if(n%i==0): return False return True #空间换时间的快速素数表创建 def getPrimeList_fast(num): pList=[] visited=[0]*(num+1) visited[0]=1 visited[1]=1 for i in xrange(0,num+1): if(visited[i]==1): continue else: if(isPrime_f(i)): pList.append(i) j=1 while(1): tmp=j*i j+=1 if(tmp&gt;num): break visited[tmp]=1 else: continue return pList 四、两算法时间复杂度对比： python自带记录代码运行时间的模块timeit，编写如下代码： t1=Timer(&quot;getPrimeList(100000)&quot;,&quot;from __main__ import getPrimeList&quot;) t2=Timer(&quot;getPrimeList_fast(100000)&quot;,&quot;from __main__ import getPrimeList_fast&quot;) print t1.timeit(1) print t2.timeit(1) 运行结果： 0.164174172965 #优化算法 0.0783876242201 #空间换时间法 五、总结：两种算法的优化效果都非常的好，第二种方法虽然非常快，但是十分耗费空间，这时，算法的选择就需要大家根据需求进行必要选择了。","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"}]},{"title":"openssl生成pem文件格式详解","date":"2017-01-31T10:29:11.905Z","path":"2017/01/31/pem_format/","text":"一、前言：前一阵看到pem格式的文件，对这一格式非常的陌生，于是查阅了一些资料，了解的同时在自己的blog做一个简单的记录，方便记忆以及查看。 OpenSSL 使用 PEM 文件格式存储证书和密钥。 这篇文章的 pem 格式讲解大部分文章整理自一篇讲解的不错的博客。http://blog.sina.com.cn/s/blog_4fcd1ea30100yh4s.html 二、openssl介绍：OpenSSL 是一个安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。（摘自百度百科） 小插曲： openssl由于缓冲区边界检查问题，产生严重的漏洞–Heartbleed（中文译为“心脏出血”） 使用openssl的网站，服务器都会遭受重创，详情请见http://baike.baidu.com/view/12769298.htm 三、openssl windows安装：原来，在64位系统上安装openssl很麻烦，但是现在只需要到这个网站http://gnuwin32.sourceforge.net/packages/openssl.htm下载安装程序，“无脑”安装即可（双击安装，一直下一步） 注意：安装完别忘了在环境变量中加入安装的openssl的bin目录 四、OPENSSL中RSA公，私钥文件（PEM格式）解析：PKCS#1 RSA算法标准中定义 RSA 私钥语法：RSAPrivateKey ::= SEQUENCE {version Version,modulus INTEGER, – npublicExponent INTEGER, – eprivateExponent INTEGER, – dprime1 INTEGER, – pprime2 INTEGER, – qexponent1 INTEGER, – d mod (p-1)exponent2 INTEGER, – d mod (q-1)coefficient INTEGER, – (inverse of q) mod potherPrimeInfos OtherPrimeInfos OPTIONAL} 类型RSAPrivateKey 的各域具有以下意义：• version 是版本号，为了与本文档的今后版本兼容。本篇文档的这个版本号应该是0，如果使用了多素数，则版本号应该是1。Version ::= INTEGER { two-prime(0), multi(1) }(CONSTRAINED BY {– version must be multi if otherPrimeInfos present –})• modulus 是RSA合数模n。• publicExponent 是RSA的公开幂e。• privateExponent 是RSA的私有幂d。• prime1 是n的素数因子p。• prime2 i是n的素数因子q。• exponent1 等于d mod (p − 1)。• exponent2 等于d mod (q − 1)。• coefficient 是CRT系数 q–1 mod p。• otherPrimeInfos 按顺序包含了其它素数r3, …, ru的信息。如果version是0 ，它应该被忽略；而如果version是1，它应该至少包含OtherPrimeInfo的一个实例。OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfoOtherPrimeInfo ::= SEQUENCE {prime INTEGER, – riexponent INTEGER, – dicoefficient INTEGER – ti}OtherPrimeInfo的各域具有以下意义：• prime 是n的一个素数因子ri ，其中i ≥ 3。• exponent 是di = d mod (ri − 1)。• coefficient 是CRT系数 ti = (r1 · r2 · … · ri–1)–1 mod ri。 PKCS#1 RSA算法标准中定义 RSA 公钥语法RSAPublicKey ::= SEQUENCE {modulus INTEGER, – npublicExponent INTEGER – e} 类型RSAPublicKey的域具有以下意义：• modulus 是RSA的合数模n。• publicExponent 是RSA公开幂e。 五、在OpenSSL中生成RSA私钥，公钥文件并解析：RSA私钥文件 生成命令： openssl genrsa -out private_rsa.pem 1024 生成的私钥pem文件内容如下： -----BEGIN RSA PRIVATE KEY----- MIICXAIBAAKBgQDnsN1F66mF6h6y/XpyN+ZU/w5AyeWBjZNIqi33/ATn4qQpw+kD HrKyF7sQ/RNw6tibM90iM6VOA14305umPbPROJJs3JoB6Lao74SUm58aO9T+Ct7r O52E+3r5jyDQicdRl6lIhLigNADXPD/KoNwfrRrCyw4wTHMZhSHc8eUHeQIDAQAB AoGABVTIgqddiztL4Yp7ms02e5Yy2cLLiSOc0/s2e5JM+pj4dg2P+wZlzjtFjqqE HAELYubam8LcduMU8+vmlPiufoK9fo47fLsX1PFCY9TDKL1dFlZgBAmJU7hR27h/ gCo4r3PMub/snq7n+skrbarZbX1J6Q1o5UYKFIrrIjNObEECQQD0DIzIdMObPUUu W+JXg10kz/ayYn3irxZmp5ngc+b9WZfSOPehZBsLWsIb1eC7y9DZMhZfBQ/sPaO8 0tvqJMUFAkEA8wlj3B3zK20pK+Hj+vFiAlaQmqILTSfv/9jMm8tbVfXt+bHrmZdN jruGVQDb7V2pW9HeG5PgDB3vKXeOiVfC5QJAYikKFzaf1rj2ModSqtBzjnL3Txi+ eYbjA7c19UmpBw4aOrwfHhMdrZt7p6aHFgIMps+2n9Fxbhv8194YBj1z4QJAPONW XFg4iuGvVeoi9sSwvEs5sTP1xt/BlgSXxlRdTpztgQgdMX6hlKfQkM1FTCOSAYoD rj8O+5ooR+hHEoulLQJBAOtaMvMWIOG7mARngpwqfJ07L41/T0ITHteiiYJfCurz kLVCx1XA3MlN+u5gn7osUHMbah0Ze3uakSZ6za3mL5Y= -----END RSA PRIVATE KEY----- 此时文件为BASE64编码，在openssl中执行以下命令，将BASE64编码的文件装换成二进制编码： openssl base64 -d -in private_rsa.pem -out private.pem 生成的private.pem 文件为BASE64解码后的文件，此文件是将RSA密钥语法中的结构进行DER编码后的二进制表现形式。 对其进行解析，解析结果: 标签头 3082025c（4 bytes） 类型为SEQUENCE 后接 604 bytes 020100 INTEGER 长度为0 内容为： VERSION 028181 INTEGER 长度为129 bytes 内容为： n（modulus） 00e7b0dd45eba985ea1eb2fd7a7237e654ff0e40c9e5818d9348aa2df7fc04e7e2a429c3e9 031eb2b217bb10fd1370ead89b33dd2233a54e035e37d39ba63db3d138926cdc9a01e8b6a8 ef84949b9f1a3bd4fe0adeeb3b9d84fb7af98f20d089c75197a94884b8a03400d73c3fcaa0 dc1fad1ac2cb0e304c73198521dcf1e50779 0203 INTEGER 长度为3 bytes 内容为： e（publicExponent） 010001 028180 INTEGER 长度为128 bytes 内容为： d（privateExponent） 0554c882a75d8b3b4be18a7b9acd367b9632d9c2cb89239cd3fb367b924cfa98f8760d8ffb 0665ce3b458eaa841c010b62e6da9bc2dc76e314f3ebe694f8ae7e82bd7e8e3b7cbb17d4f1 4263d4c328bd5d16566004098953b851dbb87f802a38af73ccb9bfec9eaee7fac92b6daad9 6d7d49e90d68e5460a148aeb22334e6c41 0241 INTEGER 长度为65 bytes 内容为： p（prime1） 00f40c8cc874c39b3d452e5be257835d24cff6b2627de2af1666a799e073e6fd5997d238f7 a1641b0b5ac21bd5e0bbcbd0d932165f050fec3da3bcd2dbea24c505 0241 INTEGER 长度为65 bytes 内容为： q（prime2） 00f30963dc1df32b6d292be1e3faf1620256909aa20b4d27efffd8cc9bcb5b55f5edf9b1eb 99974d8ebb865500dbed5da95bd1de1b93e00c1def29778e8957c2e5 0240 INTEGER 长度为64 bytes 内容为： d mod（p-1） exponent1 62290a17369fd6b8f6328752aad0738e72f74f18be7986e303b735f549a9070e1a3abc1f1e 131dad9b7ba7a68716020ca6cfb69fd1716e1bfcd7de18063d73e1 0240 INTEGER 长度为 64 bytes 内容为： d mod (q-1) exponent2 3ce3565c58388ae1af55ea22f6c4b0bc4b39b133f5c6dfc1960497c6545d4e9ced81081d31 7ea194a7d090cd454c2392018a03ae3f0efb9a2847e847128ba52d 0241 INTEGER 长度为65 bytes 内容为： q -1 mod p coefficient 00eb5a32f31620e1bb980467829c2a7c9d3b2f8d7f4f42131ed7a289825f0aeaf390b542c7 55c0dcc94dfaee609fba2c50731b6a1d197b7b9a91267acdade62f96 也可以直接使用OpenSSL命令以明文形式输出密钥的各个参数值，例如： openssl rsa -in private_rsa.pem -text -out private.txt 然后就可以在private.txt文件中查看RSA密钥中各个参数的值 六、一种python解析pem文件的方法：这里只列出解析 pem 公钥文件的方法，直接上代码： from Crypto.PublicKey import RSA pub = RSA.importKey(open(&#39;xxx\\public.pem&#39;).read()) n = long(pub.n) e = long(pub.e) print n print e 这样就得到公钥n，e了，pem 私钥获取方式类似。","tags":[{"name":"ssl","slug":"ssl","permalink":"http://www.lovebear.top/tags/ssl/"}]},{"title":"CTF--py的交易（tweakpng，firework）","date":"2017-01-18T04:00:35.879Z","path":"2017/01/18/CTF_PngAnalyse/","text":"一、前言：png格式的图片有许多的优点，在市场上也被广泛使用，通常，png中会隐藏一些重要的信息，我们需要通过一些专门的分析工具来简化我们的分析工作，这里通过一道具体的ctf题目来介绍tweakpng这款png分析工具。 在文章的末尾我们还会重点介绍pyc反编译的工具–uncompyle 原题目链接 二、原题：question 上面为给出的png文件 hint：哈，这一切都是py… 三、题解wp： 下载tweakpng，运行tweakpng，打开下载的png图片，提示crc不正确，按照提示修改crc（16进制查看器打开，修改16进制，如winhex），保存图片。 查看tweakpng分析结果，发现有Adobe专属的数据块mKBT等，且查看iTXt字段发现是使用AdobeFireworks CS5 11.0.0.484 Windows创建的。 fireworks打开图片，在右侧的图层中发现了隐藏的二维码，扫码得到一些数字字母。 猜测是16进制，复制到winhex（其他16进制编辑器都可以）中，发现是pyc文件，保存为pyc格式。 这时，需要将pyc文件反编译为py文件，这里推荐安装uncompyle.安装方法 pip install uncompyle 使用方法 uncompyle6 1.pyc &gt; 1.py 将1.pyc反编译成py文件 注意：按照官方文档的说法应该是只支持Python 2.7，uncompyle反编译效果很好。 打开文件1.py，得到flag（其中的key猜测为py，因为题目反复提示py）","tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"Python 遍历文件夹中所有文件","date":"2017-01-18T02:31:15.682Z","path":"2017/01/18/python_mapAllFiles/","text":"一、前言：有时，人们会把自己要传送的秘密藏在许多文件中的一个文件里。我们要想一个一个的翻查这些文件，直到找到目标文件可谓是大海捞针。这时，我们需要用到强大的python，使用python来自动遍历一个文件夹中的所有文件。这里介绍的方法是os.walk()。 二、解决方案：先上一段我的测试代码： import os dir=&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\www&#39; def mapAll(dir): for parent,folders,files in os.walk(dir): for file in files: dir=os.path.join(parent,file) f=open(dir) str=f.read() if(&#39;KEY&#39; in str): print dir mapAll(dir) dir为你要遍历的文件夹目录os.walk()返回三个列表，parent为父目录，folders为文件夹名，files为文件名（经测试，这里返回的文件包括子文件夹中包含的文件） 通过 os.path.join(parent,file) 得到完整的文件目录，这样可以访问所有文件了，读取每一个文件，寻找关键字，找到关键字输出文件夹位置。 三、总结：我用这个代码找到了藏在许多文件中的key文件，得到了最后的flag。","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"}]},{"title":"CTF--Airdecap-ng分析实战","date":"2017-01-17T11:06:05.787Z","path":"2017/01/17/CTF_Airdecap-ng/","text":"一、前言：Airdecap-ng十分的强大，他被用作无线网络的分析与破解中，有linux版本和windows版本，大家可以根据自己的系统进行下载安装，下面通过一道简单的ctf实战题来接触了解一下Airdecap的强大之处。 原题目链接 二、开始使用airdecap-ng：1. 用aircrack-ng检查cap包:aircrack-ng-1.1-win\\bin&gt;aircrack-ng.exe shipin.cap 2. 使用弱口令字典破解wpa加密:aircrack-ng.exe shipin.cap -w wordlist.txt 这里wordlist.txt是弱口令字典，包含了常见的路由器密码，可以网上下载到 这一步骤可以使用EWSA软件进行破解，得到密码88888888 3. 用密码解密cap:airdecap-ng.exe shipin.cap -e 0719 -p 88888888 使用到了刚才的essid和破解的密码 于是在目录下生成一个shipin-dec.cap，使用wireshark打开,找到A记录的第一个，即为flag","tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"CTF--python hashlib库中MD5用法","date":"2017-01-17T08:21:33.455Z","path":"2017/01/17/CTF_Python_MD5/","text":"一、前言：这篇博客介绍python hashlib库的MD5用法，通过一道具体的ctf题目来引入 原题目链接 二、原题：question 破解下面的密文： 83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 13823 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 11264 68 62 70 61 112 111 112 flag格式flag{}[这里注意，如果题目显示一些乱码，需要更改浏览器编码为GBK，不同浏览器修改方式不同] 三、代码及注释# -*- coding: utf-8 -*- import hashlib s=&#39;83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110 127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 138 23 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 112 64 68 62 70 61 112 111 112&#39; l=s.split(&#39; &#39;) t=&#39;&#39; for i in l: t+=chr(int(i)-13) #得到部分flag及其md5 print t m=t[-32:] dic=&#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~ &#39; #可打印字符 for i1 in dic: #枚举所有情况，进行md5后与给定md5比较，相等，即为flag for i2 in dic: for i3 in dic: for i4 in dic: md5 = hashlib.md5() b = &#39;flag{www_shiyanbar_com_is_very_good_&#39; +i1+i2+i3+i4+&#39;}&#39; md5.update(b) if md5.hexdigest() == m: print &#39;%s&#39; % b python库中的md5函数使用简便，而且运行速度很快","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"},{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"},{"name":"md5","slug":"md5","permalink":"http://www.lovebear.top/tags/md5/"}]},{"title":"CTF--欧几里得求逆","date":"2017-01-17T07:20:37.210Z","path":"2017/01/17/CTF_EuclidInversion/","text":"一、前言：最近做了一道ctf的题目，是关于仿射函数的，本身题目比较简单，这里不过多介绍，其中有一个环节需要进行乘法逆元的求解，这里需要用到欧几里得求逆的方法，是一种很好的求乘法逆元的思想，这里简单介绍，也相当于做一下笔记。 二、算法介绍：44 5 0 1|8 4 1 -8|1 1 -8 9 如上述，假设我们要求5对44的模逆 第一行为模 第二行第一个数为元，0，1固定，8是44/5的值 第三行4为(44 mod 5)，1为右上角的值，-8是(0-1*8)[0，1，8为上一行的后三个数]，1为5/4 第四行的1为(5 mod 4)， -8为右上角的值， 9为(1-(-8)*1) 当最左边出现1的时候，9就是我们需要的值，即5对44模逆的结果为9 三、代码：def Moni(a,n): p = a q = n x = 0 y = 1 z = int(q)/p while(1 != p): t = p p = q % p q = t t = y y = x - y*z x = t z = int(q)/p y=y%n if(y &lt; 0): y += n return y &#39;&#39;&#39; p x y(q=last p)|z 26 5 0 1|5 1 5 -5(21) &#39;&#39;&#39; y=Moni(5,26)","tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"CTF--快速提交2--基于学习的快速提交","date":"2017-01-12T01:29:01.340Z","path":"2017/01/12/CTF_Fastpost2/","text":"一、前言：上次介绍了简单的fastpost方法，这次我们来看一个稍微复杂的，基于学习的快速提交 原题目链接 二、原题：question 红色的数字会在短时间内变化，所以通过脚本解决这个问题。 三、代码及注释# -*- coding: utf-8 -*- import requests import re url = &#39;http://ctf5.shiyanbar.com/ppc/acsii.php&#39; #post的地址 session = requests.Session() f = session.get(url) #获取界面html zz = r&#39;red&quot;&gt;(.*)&lt;/div&gt;&#39; #匹配红色字段 a = re.findall(zz,f.content)[0] a=a.replace(&#39;&lt;br/&gt;&#39;,&#39;&lt;br /&gt;&#39;) a=a.replace(&#39;&lt;br&gt;&#39;,&#39;&lt;br /&gt;&#39;) #图形替换为对应的数字 a=a.replace(&#39;xxxxx&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;&amp;nbsp;xxxx&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;xxxxx&lt;br /&gt;&#39;,&#39;5&#39;) a=a.replace(&#39;&amp;nbsp;xx&lt;br /&gt;&amp;nbsp;&amp;nbsp;x&amp;nbsp;x&amp;nbsp;&amp;nbsp;&lt;br /&gt;&amp;nbsp;&amp;nbsp;x&amp;nbsp;&amp;nbsp;&lt;br /&gt;&amp;nbsp;&amp;nbsp;x&amp;nbsp;&amp;nbsp;&lt;br /&gt;xxxxx&lt;br /&gt;&#39;,&#39;1&#39;) a=a.replace(&#39;&amp;nbsp;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;xxxxx&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&#39;,&#39;4&#39;) a=a.replace(&#39;&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;&#39;,&#39;0&#39;) a=a.replace(&#39;&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;&amp;nbsp;xx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;&#39;,&#39;8&#39;) a=a.replace(&#39;&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&amp;nbsp;&lt;br /&gt;&amp;nbsp;&amp;nbsp;xx&amp;nbsp;&lt;br /&gt;&amp;nbsp;x&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;xxxxx&lt;br /&gt;&#39;,&#39;2&#39;) a=a.replace(&#39;&lt;br /&gt;&lt;br /&gt;&#39;,&#39;&#39;) a=a.replace(&#39;&lt;br /&gt;&#39;,&#39;&#39;) post = session.post(url,{&#39;inputNumber&#39;:a}) #获得html print post.content 得到了flag，可以提交啦，以后的fastpost都可以套用这个。","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"},{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"CTF--快速提交（fastpost）","date":"2017-01-08T13:07:08.628Z","path":"2017/01/08/CTF_Fastpost/","text":"一、前言：CTF比赛中，fastpost问题应该是非常常见的题型，这种类型题的代码基本类似，采用脚本自动提交即可，这里给出python2版本的代码，采用的是request库 原题目链接 二、原题： 红色的数字会在短时间内变化，所以通过脚本解决这个问题。 三、代码及注释# -*- coding: utf-8 -*- import hashlib import requests import re url = &#39;http://ctf5.shiyanbar.com/ppc/sd.php&#39; #post的地址 session = requests.Session() f = session.get(url) #获取界面html zz = r&#39;red&quot;&gt;(.*)&lt;/div&gt;&#39; #匹配红色字段 a = re.findall(zz,f.content)[0]#获取题目中的sha1值 for x in range (0,100001): sx = str(x) xmd5 = hashlib.md5(sx).hexdigest()#md5加密 xsha1 = hashlib.sha1(xmd5).hexdigest()#sha1加密 if xsha1 == a:#比较是否与题目的sha1值相同 post = session.post(url,{&#39;inputNumber&#39;:x}) #获得html print post.content 得到了flag，可以提交啦，以后的fastpost都可以套用这个。","tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"Linux开机自动运行普通用户python脚本","date":"2017-01-02T03:37:40.926Z","path":"2017/01/02/AutoRunPython_Linux/","text":"一、前言：最近无聊写了一个监控键盘按键的简单恶意软件，因为我的电脑不可能24小时开机监控，费时费力，于是想到我还有个云服务器，可以在云服务器上持续运行我的服务接收端来进行24小时监控。由于我的恶意软件用python编写的（开发挺快的），所以需要在服务器中设置开机自动运行我的python服务器脚本，服务器环境为linux。windows服务器比较简单，把要启动的快捷方式放到C:\\Users\\用户\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup即可实现。(AppData文件夹在windows中是默认隐藏的) 二、解决方案：Linux在启动时，会自动执行/etc/rc.d目录下的初始化程序，因此我们可以把启动任务放到该目录下。 测试环境：CentOS，管理员:root，普通用户：test1，脚本文件放在/home/test1中， 脚本名：test.py 1.因为其中的rc.local是在完成所有初始化之后执行，因此我们可以把启动脚本写到里面2.用root账号登陆Linux，vim /etc/rc.d/rc.local编辑文件，在最后加入两行需要执行的脚本程序： cd /home/test1 (该步不可少，否则会提示没有权限打开&#39;test.log&#39;文件) su test1 -c &quot;python /home/test1/test.py&quot; (把要执行的命令作为一个参数传递级su) 三、测试：重新启动机器，测试一下，是不是python脚本已经自动运行起来了呢！","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.lovebear.top/tags/Linux/"},{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"}]},{"title":"OCR--基于字符训练方法","date":"2017-01-01T13:18:26.814Z","path":"2017/01/01/CTF_OCR_Training/","text":"一、前言：最近做了一道关于OCR的题，看到图片中的文字（数字）都非常清晰，第一时间想到了使用pytesser，但是在写完代码后，发现并不能识别出来，本来pytesser的识别率就不是很高。后来发现这些数字还有一个规律，相同的数字基本都是一个样式的，于是，想到了字符训练的方法，即，分离出每个字符，再将其他图片中的文字与之匹配的方法。 原题目是计算图片中的数乘以图片名字并相加，得出最终结果。图片文件链接 提取码： o9tn原题目链接 二、字符训练：寻找0-9的特征，截出10个特征 #-*- encoding: utf-8 -*- from PIL import Image box1 = (0,0,6,10) #分成四个格子 box2 = (10,0,16,10) box3 = (20,0,26,10) box4 = (30,0,36,10) def openim(path): return Image.open(path) #训练0-9数字图片 img0 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\1.bmp&#39;) i0 = img0.crop(box2) i0.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\0.bmp&#39;) img1 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\2.bmp&#39;) i1 = img1.crop(box4) i1.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\1.bmp&#39;) img2 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\1.bmp&#39;) i2 = img2.crop(box4) i2.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\2.bmp&#39;) img3 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\3.bmp&#39;) i3 = img3.crop(box3) i3.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\3.bmp&#39;) img4 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\13.bmp&#39;) i4 = img4.crop(box2) i4.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\4.bmp&#39;) img5 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\3.bmp&#39;) i5 = img5.crop(box1) i5.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\5.bmp&#39;) img6 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\1.bmp&#39;) i6 = img6.crop(box3) i6.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\6.bmp&#39;) img7 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\1.bmp&#39;) i7 = img7.crop(box1) i7.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\7.bmp&#39;) img8 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\3.bmp&#39;) i8 = img8.crop(box4) i8.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\8.bmp&#39;) img9 = openim(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\7.bmp&#39;) i9 = img9.crop(box3) i9.save(&#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\9.bmp&#39;) 三、根据训练结果匹配：#-*- encoding: utf-8 -*- from PIL import Image def openim(path): #打开图片 return Image.open(path) def print1(im): width = im.size[0] #获得像素点集合（作为识别标识） height = im.size[1] pix = im.load() result = [] for x in range(width): for y in range(height): result.append(pix[x,y]) return result def convert1(img): img = img.convert(&quot;L&quot;) #灰度化 WHITE, BLACK = 255, 0 img = img.point(lambda x: WHITE if x &gt;= 230 else BLACK) #有颜色的地方全部变黑 img = img.convert(&#39;1&#39;) return img def cut(img): box1 = (0,0,6,10) #裁剪成4个盒子训练，box中是坐标 box2 = (10,0,16,10) box3 = (20,0,26,10) box4 = (30,0,36,10) im1 = img.crop(box1) im2 = img.crop(box2) im3 = img.crop(box3) im4 = img.crop(box4) return im1,im2,im3,im4 def OCR(img): #把4个数字分开，分别进行匹配 test1 = convert1(img) im1,im2,im3,im4 = cut(test1) result = [] for i in range(10): if print1(im1) == font[i]: result.append(str(i)) for i in range(10): if print1(im2) == font[i]: result.append(str(i)) for i in range(10): if print1(im3) == font[i]: result.append(str(i)) for i in range(10): if print1(im4) == font[i]: result.append(str(i)) return int(&#39;&#39;.join(result)) def getfont(): #训练 font = [] path = &#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\font\\\\&#39; name = r&#39;.bmp&#39; for i in range(10): im = openim(path+str(i)+name) font.append(print1(convert1(im))) return font font = getfont() path = &#39;C:\\\\Users\\\\lovebear96\\\\Desktop\\\\bmp\\\\&#39; sum = 0 for i in range(1,10000): #根据训练结果匹配得数字 img = openim(path+str(i)+&#39;.bmp&#39;) sum+=i*int(OCR(img)) print &#39;sum =&#39;+str(sum)","tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.lovebear.top/tags/ctf/"}]},{"title":"XX-NET简介及安装","date":"2017-01-01T11:02:05.989Z","path":"2017/01/01/XX-NET/","text":"一、前言：很多同学都很想翻墙，去浏览一些国外的网站，比如facebook，twitter，youtube，google什么的。当然国内有很多“替代品”，但是，讲道理，还是这些国外的经典网站比较全。下面来介绍一款非常稳定的翻墙利器–XX-NET 二、简单介绍：原来大多数人都使用GoAgent插件来“翻墙”，但是自从GoAgent被和谐掉后，涌现的大批其他插件都达不到理想的效果。于是，出现了XX-NET这一翻墙神器。我们可以认为是GoAgent的后代产物 三、特性： 集成GoAgent、GoGoTest等自动扫描IP，省事省力； Web界面，人性化交互，傻瓜易用； 内置了公共 appid, 方便新手； 方便易用的细节、细节提示； 主要支持浏览器： Chrome， Firefox 四、使用方法：这里直接贴出XX-NET的Github中文安装下载文档，其中图文并全，讲的详细而且准确，这里只是简单介绍这款翻墙利器，安装及下载请参考下面链接。 XX-NET Github中文安装及使用文档 五、注意：XX-NET只是浏览器的一个插件，所以实现的是网站翻墙浏览，即，你可以浏览一些国外的网站，如youtube（亲测不卡），google什么的。如果你先玩国外的游戏，那你还是需要购买相应的vpn，并购买加速器。","tags":[{"name":"翻墙","slug":"翻墙","permalink":"http://www.lovebear.top/tags/翻墙/"}]},{"title":"Python unexpected indent 解决","date":"2017-01-01T06:30:16.427Z","path":"2017/01/01/python_indent_err/","text":"一、前言：python中最常见的错误就是unexpected indent错误了，经常检查发现代码没什么问题，但是就是不知道哪儿错了，提示错误如下： IndentationError: unexpected indent 其实就是缩进问题，缩进中有的地方用了tab，有的地方用了space，很多时候排查不方便，本文提供一个直观的办法解决 二、解决方案：本文使用notepad++文本编辑器，其他文本编辑器自行百度相似的方法 notepad++菜单栏选择 view(视图)--&gt;Show Symbol(显示符号)--&gt;Show White Space and Tab(显示空格和制表符) 这样在代码中会直观的显示出tab和space，只要保证缩进中都是统一的符号（不能space和tab一起用，只能用俩者的一种），错误就可以解决。","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"}]},{"title":"Notepad++配置python环境","date":"2016-12-15T00:27:34.350Z","path":"2016/12/15/notepad++ And python/","text":"一、前言：python是比较轻量级的，但是一些IDE为python集成了许多插件，造成其很大（如python xy），今天我们可以在文本编辑器中（本文使用notepad++）连接python,还原轻巧的python。 二、前期准备：1.python下载（最好是python 2.7版本）：python的msi也就十几M，下载很快，下载完双击安装即可（注意，记住自己的python安装目录） 下载传送门 2.环境变量配置:环境变量的配置是为了让大家在任何位置输入python时，操作系统都会自动寻找到python的位置，并运行它。把刚才安装的python目录加入到系统环境变量中。 3.任意一款文本编辑器这里推荐两款： Notepad++: 下载传送门 Sublime: 下载传送门PS. 此处给出的下载版本都是官网版本，sublime Text 3正版会收费，大家可以自行在网上找破解版。PS. 本文使用notepad++ 三、配置notepad++： 点击notepad++上部菜单栏的run–&gt;run，出现弹窗（或直接按F5） 输入 cmd /k 你的python安装目录\\python “$(FULL_CURRENT_PATH)” &amp; PAUSE &amp; EXIT 比如我的安装目录为E：\\python27 点击save，为python运行设置快捷键（注意，不能与notepad++内部热键冲突，我的是ctrl+F5） 四、测试notepad++中新建一个文档，输入print 1，保存，ctrl+F5运行，是不是就运行出结果了呢！","tags":[{"name":"python","slug":"python","permalink":"http://www.lovebear.top/tags/python/"}]},{"title":"Pacman_project1代码及解析","date":"2016-12-13T13:37:20.392Z","path":"2016/12/13/Pacman_project1_code/","text":"一、前言：初学人工智能，感到非常好玩，老师留了一个Pacman Project，经查阅，伯克利大学的人工智能课程也用这个Project作为实验教材。为了方便同学们，我写了Project 1——search的代码，并对每行代码进行详细的注释解析。（网上有别人写好的代码，但是很乱，而且没有注释。。。） 二、进入正题：1.问题1：应用深度优先算法找到一个特定的位置的豆你的code应该能顺利解决以下问题：python pacman.py -l tinyMaze -p SearchAgentpython pacman.py -l mediumMaze -p SearchAgentpython pacman.py -l bigMaze -z .5 -p SearchAgent 废话不多说，直接上代码加注释 def graphSearch(problem, fringe): pgss=problem.getStartState() #获取problem的初始状态 print &quot;Start:&quot;, pgss #打印problem的初始状态 print &quot;Is the start a goal?&quot;, problem.isGoalState(pgss) #判断初始状态是目标状态吗 print &quot;Start&#39;s successors:&quot;, problem.getSuccessors(pgss) #打印初始状态的子状态（与这一状态连接的可达状态） visited = [] #记录这个状态是否访问过，访问过的状态都被添加到visited列表里 fringe.push([(pgss, &quot;Stop&quot; , 0)]) #向数据及结构（依fringe定义的数据结构而定）压入初始状态三元组构成 #的访问路径，三元组元素分别为状态，方向，访问步数 while not fringe.isEmpty(): #数据结构不为空一直循环 path = fringe.pop() #将数据弹出一个（栈顶，队首...）路径 s = path[len(path)-1] #取得路径末的三元组（及访问路径中最后一个状态所在的三元组） s = s[0] #取得本路径的最后状态 if problem.isGoalState(s): #如果取得的这最后一个状态就是我们的目标状态，则搜索结束 return [x[1] for x in path][1:] #返回路径中所有的方向（除去初始状态的方向） if s not in visited: #如果这个状态还没被访问过 visited.append(s) #访问这个状态，并将这个状态添加到访问记录列表visited[]中 for successor in problem.getSuccessors(s): #遍历现状态的子状态 if successor[0] not in visited: #子状态没有被访问过 successorPath = path[:] #创建新的子状态路径（复制当前状态的路径），此处的[:] #为了防止python的引用处理，这样可以真正创建新的路径 successorPath.append(successor)#在原状态路径后面添加上当前访问的子状态，得到新的状态路径 fringe.push(successorPath) #将新的状态路径压入数据结构中 return [] def depthFirstSearch(problem): &quot;&quot;&quot; Search the deepest nodes in the search tree first. Your search algorithm needs to return a list of actions that reaches the goal. Make sure to implement a graph search algorithm. To get started, you might want to try some of these simple commands to understand the search problem that is being passed in: print &quot;Start:&quot;, problem.getStartState() print &quot;Is the start a goal?&quot;, problem.isGoalState(problem.getStartState()) print &quot;Start&#39;s successors:&quot;, problem.getSuccessors(problem.getStartState()) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; fringe = util.Stack() #fringe数据结构为栈，进行dfs return graphSearch(problem, fringe) 2.问题2：宽度优先算法python pacman.py -l mediumMaze -p SearchAgent -a fn=bfspython pacman.py -l bigMaze -p SearchAgent -a fn=bfs -z .5 def breadthFirstSearch(problem): &quot;&quot;&quot;Search the shallowest nodes in the search tree first.&quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; fringe = util.Queue() #fringe数据结构为队列，进行bfs return graphSearch(problem, fringe) 3.问题3：宽度优先算法（代价一致算法）python pacman.py -l mediumMaze -p SearchAgent -a fn=ucspython pacman.py -l mediumDottedMaze -p StayEastSearchAgentpython pacman.py -l mediumScaryMaze -p StayWestSearchAgent def uniformCostSearch(problem): &quot;&quot;&quot;Search the node of least total cost first.&quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; cost = lambda aPath: problem.getCostOfActions([x[1] for x in aPath]) #计算出每条路径的总代价，通过总代价 #作为优先级进行搜索 fringe = util.PriorityQueueWithFunction(cost) #fringe数据结构为优先队列 return graphSearch(problem, fringe) 4.问题4：A* 算法python pacman.py -l bigMaze -z .5 -p SearchAgent -a fn=astar,heuristic=manhattanHeuristic def nullHeuristic(state, problem=None): &quot;&quot;&quot; A heuristic function estimates the cost from the current state to the nearest goal in the provided SearchProblem. This heuristic is trivial. &quot;&quot;&quot; return 0 def aStarSearch(problem, heuristic=nullHeuristic): &quot;&quot;&quot;Search the node that has the lowest combined cost and heuristic first.&quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; cost = lambda aPath: problem.getCostOfActions([x[1] for x in aPath]) + heuristic(aPath[len(aPath)-1][0], problem) fringe = util.PriorityQueueWithFunction(cost) #A*是对代价一致搜索算法的改进，加入了一个估计代价h return graphSearch(problem, fringe) 5.问题5：找到所有的角落python pacman.py -l tinyCorners -p SearchAgent -a fn=bfs,prob=CornersProblempython pacman.py -l mediumCorners -p SearchAgent -a fn=bfs,prob=CornersProblem def getStartState(self): &quot;&quot;&quot; Returns the start state (in your state space, not the full Pacman state space) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; return (self.startingPosition, [self.corners[0], self.corners[1], self.corners[2], self.corners[3]]) #agent初始状态的位置，和四个角落的豆的位置 def isGoalState(self, state): &quot;&quot;&quot; Returns whether this search state is a goal state of the problem. &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; return len(state[1]) == 0 #state[0]为当前agent位置， state[1]为还没吃到的点的位置，state[1]为 #空时，结束为终止位置 def getSuccessors(self, state): &quot;&quot;&quot; Returns successor states, the actions they require, and a cost of 1. As noted in search.py: For a given state, this should return a list of triples, (successor, action, stepCost), where &#39;successor&#39; is a successor to the current state, &#39;action&#39; is the action required to get there, and &#39;stepCost&#39; is the incremental cost of expanding to that successor &quot;&quot;&quot; successors = [] for action in [Directions.NORTH, Directions.SOUTH, Directions.EAST, Directions.WEST]: # Add a successor state to the successor list if the action is legal # Here&#39;s a code snippet for figuring out whether a new position hits a wall: # x,y = currentPosition # dx, dy = Actions.directionToVector(action) # nextx, nexty = int(x + dx), int(y + dy) # hitsWall = self.walls[nextx][nexty] &quot;*** YOUR CODE HERE ***&quot; x,y = state[0] #获取agent当前位置 dx, dy = Actions.directionToVector(action) nextx, nexty = int(x + dx), int(y + dy) #下一个位置坐标 hitsWall = self.walls[nextx][nexty] #判断是否撞到墙 if not hitsWall: #判断，没撞到墙 nextPosition = (nextx, nexty) #下个位置坐标 cornersLeft = state[1][:] #复制当前剩余没吃到的点 if nextPosition in cornersLeft: #如果下个坐标在剩余没吃到的点中 cornersLeft.remove(nextPosition) #因为下一个就能把它吃掉，所以把这个点从剩余 #没吃到点的列表中删除 nextState = (nextPosition, cornersLeft) #计算下一个点的坐标 cost = 1 #代价为1，（步数为1） successors.append( ( nextState, action, cost) ) #属于可达的子状态，加入到子状态列表 self._expanded += 1 # DO NOT CHANGE return successors 6.问题6：角落问题（启发式）python pacman.py -l mediumCorners -p AStarCornersAgent -z 0.5 def cornersHeuristic(state, problem): &quot;&quot;&quot; A heuristic for the CornersProblem that you defined. state: The current search state (a data structure you chose in your search problem) problem: The CornersProblem instance for this layout. This function should always return a number that is a lower bound on the shortest path from the state to a goal of the problem; i.e. it should be admissible (as well as consistent). &quot;&quot;&quot; corners = problem.corners # These are the corner coordinates walls = problem.walls # These are the walls of the maze, as a Grid (game.py) &quot;*** YOUR CODE HERE ***&quot; heuristic = 0 cornersLeft = state[1][:] #剩余点的坐标 referencePoint = state[0] #当前点的坐标 while len(cornersLeft) &gt; 0: #当有点剩余（未吃完所有点） closestCorner = closestPoint(referencePoint, cornersLeft) #当前点坐标和未吃到点中的哪一个离得最近 heuristic += euclidieanDistance(referencePoint, closestCorner) #估计值h加上当前点到最近未吃点的距离 referencePoint = closestCorner #当前点变为最近未吃点，因为已经走到了那个点 cornersLeft.remove(closestCorner) #从未吃点列表中将刚才吃掉的点删除 return heuristic #return 0 # Default to trivial solution def closestPoint (fromPoint, candidatesList): if len(candidatesList) == 0: #如果未吃点列表为空，证明所有点都被吃了，返回none return None closestCorner = candidatesList[0] #获取未吃点列表中的第一个点 closestCost = euclidieanDistance(fromPoint, closestCorner) #计算当前点到第一个点距离 for candidate in candidatesList[1:]: thisCost = euclidieanDistance(fromPoint, candidate) if closestCost &gt; thisCost: #循环遍历列表，返回距当前点最近的一个未吃点的坐标 closestCost = thisCost closestCorner = candidate return closestCorner def euclidieanDistance (pointA, pointB): return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])#因为坐标为表格化，不能斜着走，所以最短距离为|x|+|y| 7.问题7：吃掉所有的豆子（这个程序有点卡，稍等一会）python pacman.py -l testSearch -p AStarFoodSearchAgentpython pacman.py -l trickySearch -p AStarFoodSearchAgent def foodHeuristic(state, problem): &quot;&quot;&quot; Your heuristic for the FoodSearchProblem goes here. This heuristic must be consistent to ensure correctness. First, try to come up with an admissible heuristic; almost all admissible heuristics will be consistent as well. If using A* ever finds a solution that is worse uniform cost search finds, your heuristic is *not* consistent, and probably not admissible! On the other hand, inadmissible or inconsistent heuristics may find optimal solutions, so be careful. The state is a tuple ( pacmanPosition, foodGrid ) where foodGrid is a Grid (see game.py) of either True or False. You can call foodGrid.asList() to get a list of food coordinates instead. If you want access to info like walls, capsules, etc., you can query the problem. For example, problem.walls gives you a Grid of where the walls are. If you want to *store* information to be reused in other calls to the heuristic, there is a dictionary called problem.heuristicInfo that you can use. For example, if you only want to count the walls once and store that value, try: problem.heuristicInfo[&#39;wallCount&#39;] = problem.walls.count() Subsequent calls to this heuristic can access problem.heuristicInfo[&#39;wallCount&#39;] &quot;&quot;&quot; position, foodGrid = state &quot;*** YOUR CODE HERE ***&quot; foodList = foodGrid.asList() #得到要吃的点的列表（未吃点列表） if len(foodList) == 0: #当未吃点列表为空时，停止 return 0 closestFood = closestPoint(position, foodList) #得到离当前点最近的未吃食物 return euclidieanDistance(position, closestFood) + len(foodList) 8.问题8：次最优搜索python pacman.py -l bigSearch -p ClosestDotSearchAgent -z .5 class ClosestDotSearchAgent(SearchAgent): &quot;Search for all food using a sequence of searches&quot; def registerInitialState(self, state): self.actions = [] currentState = state while(currentState.getFood().count() &gt; 0): nextPathSegment = self.findPathToClosestDot(currentState) # The missing piece self.actions += nextPathSegment for action in nextPathSegment: legal = currentState.getLegalActions() if action not in legal: t = (str(action), str(currentState)) raise Exception, &#39;findPathToClosestDot returned an illegal move: %s!\\n%s&#39; % t currentState = currentState.generateSuccessor(0, action) self.actionIndex = 0 print &#39;Path found with cost %d.&#39; % len(self.actions) def findPathToClosestDot(self, gameState): &quot;&quot;&quot; Returns a path (a list of actions) to the closest dot, starting from gameState. &quot;&quot;&quot; # Here are some useful elements of the startState startPosition = gameState.getPacmanPosition() food = gameState.getFood() walls = gameState.getWalls() problem = AnyFoodSearchProblem(gameState) &quot;*** YOUR CODE HERE ***&quot; return search.aStarSearch(problem,search.nullHeuristic) #A*搜索 class AnyFoodSearchProblem(PositionSearchProblem): &quot;&quot;&quot; A search problem for finding a path to any food. This search problem is just like the PositionSearchProblem, but has a different goal test, which you need to fill in below. The state space and successor function do not need to be changed. The class definition above, AnyFoodSearchProblem(PositionSearchProblem), inherits the methods of the PositionSearchProblem. You can use this search problem to help you fill in the findPathToClosestDot method. &quot;&quot;&quot; def __init__(self, gameState): &quot;Stores information from the gameState. You don&#39;t need to change this.&quot; # Store the food for later reference self.food = gameState.getFood() # Store info for the PositionSearchProblem (no need to change this) self.walls = gameState.getWalls() self.startState = gameState.getPacmanPosition() self.costFn = lambda x: 1 self._visited, self._visitedlist, self._expanded = {}, [], 0 # DO NOT CHANGE def isGoalState(self, state): &quot;&quot;&quot; The state is Pacman&#39;s position. Fill this in with a goal test that will complete the problem definition. &quot;&quot;&quot; x,y = state &quot;*** YOUR CODE HERE ***&quot; return self.food[x][y] #state为终点坐标 三、总结：这东西还是挺好玩的，希望本文对大家有用","tags":[{"name":"pacman","slug":"pacman","permalink":"http://www.lovebear.top/tags/pacman/"}]},{"title":"Ubuntu Python 默认使用版本改变","date":"2016-12-11T01:29:35.966Z","path":"2016/12/11/Ubuntu-Python_Version/","text":"一、前言：ubuntu 14系统的初始默认python版本为python 2.7.6，也就是说，当我们输入 python 运行程序 ubuntu默认使用python 2.7.6而当我们想用python3运行程序时，必须用 python3 运行程序 怎么使python命令自动使用python3以上的版本运行程序呢？ 二、解决方案：只需要打开终端，输入 echo alias python=python3 &gt;&gt; ~/.bashrc source ~/.bashrc 就可以完成改变 三、测试这时，输入 python 运行程序 就可以以python3的版本运行程序啦 四、注意笔者不是很建议这样做，可能会引起不必要的麻烦，但是特殊情况需要用到这种方式。","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.lovebear.top/tags/ubuntu/"}]},{"title":"Hexo Your Blog","date":"2016-10-08T12:24:30.365Z","path":"2016/10/08/Hexo-Your-Blog/","text":"一、前言：之前逛一位ctf大神的博客，偶然发现这个Hexo，了解一下，还真是好东西，既能提高技能，又能装逼（qwq这是重点），网上的大多数教程都是大同小异，完全按照那个来搭建会失败，本文图文教程，让小白也能成功搭建起属于自己的专属Blog。 二、前期准备：1.Git：一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 下载传送门【需要翻墙】 百度云链接【提取码：3hu4】 2.Node.js:一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。 下载传送门 百度云链接【提取码：siy6】 3.任意一款文本编辑器这里推荐两款： Notepad++: 下载传送门 Sublime: 下载传送门PS. 此处给出的下载版本都是官网版本，sublime Text 3正版会收费，大家可以自行在网上找破解版。 三、配置GitHub：1. 注册GitHub账号2. 配置SSH keysPS. 命令行指令win+R打开运行窗口，输入cmd，回车，打开shell 1)检查SSH keys设置$ cd ~/. ssh 检查本机的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 2)生成新的SSH keys$ ssh-keygen -t rsa -C &quot;youremail&quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; PS. Youremail处填写你自己的邮箱，例如 lovebear@gmail.com 然后系统会要你输入密码： Enter passphrase (empty for no passphrase):&lt;输入加密串&gt; Enter same passphrase again:&lt;再次输入加密串&gt; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。 PS. 输入密码的时候没有*字样的，你直接输入就可以了。 成功生成SSH keys会在C:/User/登录用户名/.ssh产生两个文件id_rsa和id_rsa.pub PS. 登陆用户名为开机时显示的登陆用户名，默认为Administrator 3)添加SSH keys到GitHub在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。 打开生产的id_rsa.pub文件。此文件里面内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。 登陆github。点击右上角的头像 —&gt; Settings—&gt; SSH and GPG keys —&gt; New SSH key 把你id_rsa.pub中的内容（密钥）复制到key文本框中，点击 add SSH key 4)测试是否配置成功输入下面的命令，看看设置是否成功： $ ssh -T git@github.com 出现下图： The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 输入yes Hi cnfeat! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 配置成功 5)设置基本用户信息Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。 $ git config --global user.name &quot;cnfeat&quot;//用户名 $ git config --global user.email &quot;cnfeat@gmail.com&quot;//填写自己的邮箱 至此，SSH keys配置成功。四、GitHub上建立仓库（GitHub Pages）：与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务，GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。 想建立个人博客是用的第一种，形如beiyuu.github.io这样的可访问的站 PS. 每个用户名下面只能建立一个。 1.点击右上角的new Repository,创建仓库 2.填写项目信息 Resporitary name: 填写 你的账号名.github.io，例如我的登陆用户名是cckuailong，建立仓库的名称就是cckuailong.github.io Description: 填写你的仓库描述（随便写点就行） PS. 选中public选项，让大家都可以访问。记得勾选上Initialize this resporitary with a README。 3.点击Create resporitary，完成创建五、安装Git和Node.js：与安装其他软件一样，安装目录可以自选，如果不清楚，就按照默认安装。 六、Hexo Your Blog：1.Hexo简介Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。 2.打开Git找到你安装Git的目录，双击git-bash，或者 右键，在选项中点击git-bash，打开Git命令行。 3.安装Hexo在Git命令行执行下列命令： npm install -g hexo 4.初始化Hexo在你想要部署的位置建立一个新的文件夹（快捷键ctr+shift+n），命名为Hexo。在这个文件夹下，右键，选择git-bash，输入下述命令后，回车： $ hexo init Hexo随后会自动在目标文件夹下载网站所需要的所有文件。 5.生成静态界面执行 $ hexo g 生成静态页面至hexo\\public\\目录。 6.本地启动执行 $ hexo s 进行本地启动。 启动完成后，打开浏览器，输入http://localhost:4000 就可以看到效果，我们的Hexo博客已经搭建起来了。 PS. Ctrl+c停止启动，相当于断开本地启动，http://localhost:4000 将不能被访问，一般本地启动的作用是本地调试，根据博客展示效果，可以及时修改，都修改完毕后，再部署到GitHub上。（下一小节讲解如何将博客部署到GitHub） 七、将博客部署到GitHub：1.部署到GitHub前需要配置_config.yml文件，首先找到下面的内容# Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: 修改为： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: github repository:https://github.com/username/username.github.io.git branch: master PS. 两个Username处替换为自己的GitHub登陆用户名，即上面创建的仓库名。 这里注意，如果你的Hexo是3.0版本，type处的github应该更改为git，才可以部署成功。 2.执行：$ hexo g -d 完成部署。 3.登陆GitHub，打开刚才创建的仓库（Repositary），发现里面多了很多部署好的文件。 PS. 你的文件可能没有404.html和CNAME两个文件，不要急，下面会讲到。 八、DNS与GitHub Pages的绑定：1.什么是DNS？例如，www.baidu.com, www.lovebear.top 这些方便好记的网址就可以认为是DNS了。 2.购买DNS网上大多数推荐GoDaddy，但是我这里推荐百度开放云（上面的域名很便宜啊）传送门在这里 3.DNS设置1)注册DNSpod（速度快，稳定，还免费！！！）2)在左侧选中域名解析，点击，添加域名，输入你刚才购买的域名 3)点击添加成功的域名（这里是lovebear.top），进入到管理你的域名后，点击记录，添加两条记录（一个是@，另一个是www）注意：在添加记录时，会填写记录值，获得你的记录值的方式如下： Win+R打开运行，输入cmd，回车，打开shell，输入 Ping username.github.io 方括号中的ip即为你的记录值，把它填到两个记录中就可以啦。 4)登陆百度开放云，点击域名管理，点击右方的更多操作，选择域名信息 点击修改DNS，修改成图中显示的两个dns 保存 5)打开GitHub，点击Create new file，新建文件名为CNAME，内容是你刚才申请的域名 注意要保存到主干（master） 保存后发现仓库中多了个CNAME文件 至此，DNS设置完成，DNSpod第一次解析域名可能会时间稍长，至多一天，请大家耐心等待吧。九、大功告成：浏览器输入你购买的域名，是不是就成功了呢^_^","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.lovebear.top/tags/hexo/"}]}]